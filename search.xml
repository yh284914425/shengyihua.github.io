<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/09/29/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8CSDN-markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2018/09/29/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8CSDN-markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>@<a href="这里写自定义目录标题">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<a href="[mermaid语法说明](https://mermaidjs.github.io/)">^1</a></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H~2~O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://mp.csdn.net" target="_blank" rel="noopener">link</a>.</p><p>图片: <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" alt="Alt"></p><p>带尺寸的图片: <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30" alt="Alt"></p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/configure" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li style="list-style: none"><input type="checkbox"> 计划任务</li><li style="list-style: none"><input type="checkbox" checked> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>——– | —–<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | </p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><p>Markdown<br>:  Text-to-HTML conversion tool</p><p>Authors<br>:  John<br>:  Luke</p><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></p><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World 盛宜华</title>
      <link href="/2018/09/29/hello-world/"/>
      <url>/2018/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="http://i.imgur.com/CaBRleb.jpg" alt="电饭锅"><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a><br><img src="http://i.imgur.com/CaBRleb.jpg" alt="电饭锅"><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>从源码分析sentry的错误信息收集</title>
      <link href="/2018/08/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90sentry%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2018/08/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90sentry%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p><p>首先抛出几个问题：</p><ul><li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li><li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li><li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li><li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li></ul><p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p><p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p><ul><li><a href="https://github.com/moll/json-stringify-safe" target="_blank" rel="noopener">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul><li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li></ul></li><li><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">md5</a>：js 的 md5 函数。</li><li><a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li></ul><p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p><h3 id="raven-js-是如何收集错误信息的？"><a href="#raven-js-是如何收集错误信息的？" class="headerlink" title="raven.js 是如何收集错误信息的？"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p><p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function installGlobalHandler() &#123;</span><br><span class="line">  if (_onErrorHandlerInstalled) &#123; // 一个起到标志作用的全局变量</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  _oldOnerrorHandler = _window.onerror; </span><br><span class="line">  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span><br><span class="line">  // 该 _window 经过兼容，实际上就是 window</span><br><span class="line">  _window.onerror = traceKitWindowOnError;</span><br><span class="line">  _onErrorHandlerInstalled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function traceKitWindowOnError(msg, url, lineNo, colNo, ex) &#123;</span><br><span class="line"></span><br><span class="line">var exception = utils.isErrorEvent(ex) ? ex.error : ex;</span><br><span class="line">//...</span><br><span class="line">    stack = TraceKit.computeStackTrace(exception);</span><br><span class="line">    notifyHandlers(stack, true);</span><br><span class="line">    //...</span><br><span class="line">   </span><br><span class="line">    //...</span><br><span class="line">    if (_oldOnerrorHandler) &#123;</span><br><span class="line">       return _oldOnerrorHandler.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p><p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function subscribe(handler) &#123;</span><br><span class="line">    installGlobalHandler();</span><br><span class="line">    handlers.push(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p><p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> _handleOnErrorStackInfo: function(stackInfo, options) &#123;</span><br><span class="line">    options.mechanism = options.mechanism || &#123;</span><br><span class="line">      type: &apos;onerror&apos;,</span><br><span class="line">      handled: false</span><br><span class="line">    &#125;;</span><br><span class="line">    // mechanism 和错误统计来源有关</span><br><span class="line"></span><br><span class="line">    if (!this._ignoreOnError) &#123;</span><br><span class="line">      this._handleStackInfo(stackInfo, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_handleStackInfo: function(stackInfo, options) &#123;</span><br><span class="line">    var frames = this._prepareFrames(stackInfo, options);</span><br><span class="line"></span><br><span class="line">    this._triggerEvent(&apos;handle&apos;, &#123;</span><br><span class="line">      stackInfo: stackInfo,</span><br><span class="line">      options: options</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this._processException(</span><br><span class="line">      stackInfo.name,</span><br><span class="line">      stackInfo.message,</span><br><span class="line">      stackInfo.url,</span><br><span class="line">      stackInfo.lineno,</span><br><span class="line">      frames,</span><br><span class="line">      options</span><br><span class="line">    );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_processException: function(type, message, fileurl, lineno, frames, options) &#123;</span><br><span class="line">    // 首先根据 message 信息判断是否是需要忽略的错误类型</span><br><span class="line">    // 然后判断出错的文件是否在黑名单中或者白名单中</span><br><span class="line">    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span><br><span class="line">    // 最后调用上报函数</span><br><span class="line">    this._send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_send: function(data) &#123;</span><br><span class="line"></span><br><span class="line">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span><br><span class="line"></span><br><span class="line">// 交由 _sendProcessedPayload 进行进一步处理</span><br><span class="line">this._sendProcessedPayload(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_sendProcessedPayload: function(data, callback) &#123;</span><br><span class="line"></span><br><span class="line">// 对 data 增加一些必要的元信息</span><br><span class="line">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span><br><span class="line">(globalOptions.transport || this._makeRequest).call(this, &#123;</span><br><span class="line">     url: url,</span><br><span class="line">     auth: auth,</span><br><span class="line">     data: data,</span><br><span class="line">     options: globalOptions,</span><br><span class="line">     onSuccess: function success() &#123;</span><br><span class="line">       </span><br><span class="line">     &#125;,</span><br><span class="line">     onError: function failure(error) &#123;</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">// 真正发起请求的函数</span><br><span class="line">_makeRequest: function(opts) &#123;</span><br><span class="line">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span><br><span class="line">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</span><br><span class="line"></span><br><span class="line">* 每个函数只处理一件或者一些事情，保持函数的短小整洁。</span><br><span class="line">* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try &#123;</span><br><span class="line">    doSomething(a[0])</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">    Raven.captureException(e)</span><br><span class="line">&#125;` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</span><br><span class="line"></span><br><span class="line">但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</span><br><span class="line"></span><br><span class="line">* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</span><br><span class="line">* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。</span><br><span class="line">* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</span><br><span class="line"></span><br><span class="line">最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">Raven.config(&apos;http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2&apos;).install()</span><br><span class="line">let s = window.ss;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">    let b = s.b</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    Raven.captureException(e)</span><br><span class="line">    // sentry should report error now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.nomethod();</span><br><span class="line">// sentry should report error now</span><br></pre></td></tr></table></figure><p>以上例子中，sentry 会发送两个 POST 请求。</p><h3 id="raven-js-最终上报数据的格式"><a href="#raven-js-最终上报数据的格式" class="headerlink" title="raven.js 最终上报数据的格式"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p><p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;project&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;logger&quot;: &quot;javascript&quot;,</span><br><span class="line">  &quot;platform&quot;: &quot;javascript&quot;,</span><br><span class="line">  &quot;request&quot;: &#123;</span><br><span class="line">    &quot;headers&quot;: &#123;</span><br><span class="line">      &quot;User-Agent&quot;: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;url&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exception&quot;: &#123;</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;TypeError&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;Cannot read property &apos;b&apos; of undefined&quot;,</span><br><span class="line">        &quot;stacktrace&quot;: &#123;</span><br><span class="line">          &quot;frames&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;filename&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;,</span><br><span class="line">              &quot;lineno&quot;: 19,</span><br><span class="line">              &quot;colno&quot;: 19,</span><br><span class="line">              &quot;function&quot;: &quot;?&quot;,</span><br><span class="line">              &quot;in_app&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;mechanism&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;generic&quot;,</span><br><span class="line">      &quot;handled&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;transaction&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;,</span><br><span class="line">  &quot;extra&quot;: &#123;</span><br><span class="line">    &quot;session:duration&quot;: 6</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;breadcrumbs&quot;: &#123;</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;timestamp&quot;: 1534257309.996,</span><br><span class="line">        &quot;message&quot;: &quot;_prepareFrames stackInfo: [object Object]&quot;,</span><br><span class="line">        &quot;level&quot;: &quot;log&quot;,</span><br><span class="line">        &quot;category&quot;: &quot;console&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      // ...</span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;event_id&quot;: &quot;ea0334adaf9d43b78e72da2b10e084a9&quot;,</span><br><span class="line">  &quot;trimHeadFrames&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中支持的信息类型重点分为以下几种：</p><ul><li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li><li>错误信息，主要包括错误调用栈信息</li><li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li><li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li></ul><h3 id="raven-js-面包屑收集"><a href="#raven-js-面包屑收集" class="headerlink" title="raven.js 面包屑收集"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p><p>面包屑信息主要包括这几类：</p><ul><li>用户对某个元素的点击或者用户对某个可输入元素的输入</li><li>发送的 http 请求</li><li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li><li>window.location 变化信息</li></ul><p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p><p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p><ul><li>window.setTimeout</li><li>window.setInterval</li><li>window.requestAnimationFrame</li><li>EventTarget.addEventListener</li><li>EventTarget.removeEventListener</li><li>XMLHTTPRequest.open</li><li>XMLHTTPRequest.send</li><li>window.fetch</li><li>History.pushState</li><li>History.replaceState</li></ul><blockquote><p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p></blockquote><p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapEventTarget</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> proto = _window[global] &amp;&amp; _window[global].prototype;</span><br><span class="line">      <span class="keyword">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class="string">'addEventListener'</span>)) &#123;</span><br><span class="line">        fill(</span><br><span class="line">          proto,</span><br><span class="line">          <span class="string">'addEventListener'</span>,</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class="comment">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class="line">                  fn.handleEvent = self.wrap(</span><br><span class="line">                    &#123;</span><br><span class="line">                      mechanism: &#123;</span><br><span class="line">                        type: <span class="string">'instrument'</span>,</span><br><span class="line">                        data: &#123;</span><br><span class="line">                          target: global,</span><br><span class="line">                          <span class="function"><span class="keyword">function</span>: '<span class="title">handleEvent</span>',</span></span><br><span class="line"><span class="function">                          <span class="title">handler</span>: (<span class="params">fn &amp;&amp; fn.name</span>) || '&lt;<span class="title">anonymous</span>&gt;'</span></span><br><span class="line"><span class="function">                        &#125;</span></span><br><span class="line"><span class="function">                      &#125;</span></span><br><span class="line"><span class="function">                    &#125;,</span></span><br><span class="line"><span class="function">                    <span class="title">fn</span>.<span class="title">handleEvent</span></span></span><br><span class="line"><span class="function">                  );</span></span><br><span class="line"><span class="function">                &#125;</span></span><br><span class="line"><span class="function">              &#125; <span class="title">catch</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">var</span> before, clickHandler, keypressHandler;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                autoBreadcrumbs &amp;&amp;</span><br><span class="line">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class="line">                (global === <span class="string">'EventTarget'</span> || global === <span class="string">'Node'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class="line">                <span class="comment">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class="line">                clickHandler = self._breadcrumbEventHandler(<span class="string">'click'</span>);</span><br><span class="line">                keypressHandler = self._keypressEventHandler();</span><br><span class="line">                before = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; <span class="comment">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class="line">                  <span class="keyword">if</span> (!evt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">var</span> eventType;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventType = evt.type;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="comment">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class="line">                    <span class="comment">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (eventType === <span class="string">'click'</span>) <span class="keyword">return</span> clickHandler(evt);</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (eventType === <span class="string">'keypress'</span>) <span class="keyword">return</span> keypressHandler(evt);</span><br><span class="line">                &#125;;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> orig.call(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                evtName,</span><br><span class="line">                self.wrap(</span><br><span class="line">                  &#123;</span><br><span class="line">                    mechanism: &#123;</span><br><span class="line">                      type: <span class="string">'instrument'</span>,</span><br><span class="line">                      data: &#123;</span><br><span class="line">                        target: global,</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>: '<span class="title">addEventListener</span>',</span></span><br><span class="line"><span class="function">                        <span class="title">handler</span>: (<span class="params">fn &amp;&amp; fn.name</span>) || '&lt;<span class="title">anonymous</span>&gt;'</span></span><br><span class="line"><span class="function">                      &#125;</span></span><br><span class="line"><span class="function">                    &#125;</span></span><br><span class="line"><span class="function">                  &#125;,</span></span><br><span class="line"><span class="function">                  <span class="title">fn</span>,</span></span><br><span class="line"><span class="function">                  <span class="title">before</span></span></span><br><span class="line"><span class="function">                ),</span></span><br><span class="line"><span class="function">                <span class="title">capture</span>,</span></span><br><span class="line"><span class="function">                <span class="title">secure</span></span></span><br><span class="line"><span class="function">              );</span></span><br><span class="line"><span class="function">            &#125;;</span></span><br><span class="line"><span class="function">          &#125;,</span></span><br><span class="line"><span class="function">          <span class="title">wrappedBuiltIns</span></span></span><br><span class="line"><span class="function">        );</span></span><br><span class="line"><span class="function">        <span class="title">fill</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          proto,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">'removeEventListener'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">          function(orig</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> orig.call(<span class="keyword">this</span>, evt, fn, capture, secure);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">          wrappedBuiltIns</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href="http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/" target="_blank" rel="noopener">这里</a>补充一些相关的知识）。</p><p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p><h3 id="raven-js-如何和框架配合使用"><a href="#raven-js-如何和框架配合使用" class="headerlink" title="raven.js 如何和框架配合使用"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p><p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p><p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function formatComponentName(vm) &#123;</span><br><span class="line">  if (vm.$root === vm) &#123;</span><br><span class="line">    return &apos;root instance&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;</span><br><span class="line">  return (</span><br><span class="line">    (name ? &apos;component &lt;&apos; + name + &apos;&gt;&apos; : &apos;anonymous component&apos;) +</span><br><span class="line">    (vm._isVue &amp;&amp; vm.$options.__file ? &apos; at &apos; + vm.$options.__file : &apos;&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function vuePlugin(Raven, Vue) &#123;</span><br><span class="line">  Vue = Vue || window.Vue;</span><br><span class="line"></span><br><span class="line">  // quit if Vue isn&apos;t on the page</span><br><span class="line">  if (!Vue || !Vue.config) return;</span><br><span class="line"></span><br><span class="line">  var _oldOnError = Vue.config.errorHandler;</span><br><span class="line">  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) &#123;</span><br><span class="line">    var metaData = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // vm and lifecycleHook are not always available</span><br><span class="line">    if (Object.prototype.toString.call(vm) === &apos;[object Object]&apos;) &#123;</span><br><span class="line">      metaData.componentName = formatComponentName(vm);</span><br><span class="line">      metaData.propsData = vm.$options.propsData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (typeof info !== &apos;undefined&apos;) &#123;</span><br><span class="line">      metaData.lifecycleHook = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Raven.captureException(error, &#123;</span><br><span class="line">      extra: metaData</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (typeof _oldOnError === &apos;function&apos;) &#123;</span><br><span class="line">      _oldOnError.call(this, error, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = vuePlugin;</span><br></pre></td></tr></table></figure><p>应该不用进行过多解释。</p><p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href="https://docs.sentry.io/clients/javascript/integrations/react/" target="_blank" rel="noopener">这里</a></p><blockquote><p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p></blockquote><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇关于react历史的流水账</title>
      <link href="/2018/06/10/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8Ereact%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
      <url>/2018/06/10/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8Ereact%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<p>react 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。</p><p>笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。</p><p>这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。</p><h3 id="为什么是-react"><a href="#为什么是-react" class="headerlink" title="为什么是 react"></a>为什么是 react</h3><p>我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。</p><p>在 react 开源之初，相关生态体系并不完善，甚至官方还在用<code>Backbone.Router</code>加 react 来开发单页面应用。</p><p>但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是<strong>复杂的UI渲染问题（ complex UI rendering ）</strong>，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。</p><h3 id="FLUX"><a href="#FLUX" class="headerlink" title="FLUX"></a>FLUX</h3><p>在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。</p><p>FLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看<a href="https://www.10000h.top/react_flux.pdf" target="_blank" rel="noopener">这篇文章</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To summarize, Flux works well for us because the single directional data flow makes it easy to understand and modify an application as it becomes more complicated. We found that two-way data bindings lead to cascading updates, where changing one data model led to another data model updating, making it very difficult to predict what would change as the result of a single user interaction.</span><br><span class="line"></span><br><span class="line">总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。</span><br></pre></td></tr></table></figure><p>从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：</p><p><img src="https://www.10000h.top/images/flux.png" alt=""></p><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p>2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone<br>.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。</p><h3 id="react-ES6-Class"><a href="#react-ES6-Class" class="headerlink" title="react ES6 Class"></a>react ES6 Class</h3><p>实际上，在 2015.01.27 之前，我们都是在使用 <code>React.createClass</code>来书写组件。</p><p>而在 2015.01.27 这一天，也就是第一届 <code>reactjs conf</code> 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。</p><p>这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。</p><p><em>实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。</em></p><p>而在之后的 V15.5 版本（2017年4月发布），react 才将<code>React.createClass</code>的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库<code>create-react-class</code> 来支持原来的 <code>React.createClass</code> 功能。</p><h3 id="Relay-amp-GraphQL"><a href="#Relay-amp-GraphQL" class="headerlink" title="Relay &amp; GraphQL"></a>Relay &amp; GraphQL</h3><p>在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。</p><p>而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。</p><p>当然，我们使用 redux 配合相关插件，也可以不使用 Relay。</p><h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><p>在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。</p><p>并且也是在这个时候（2015年3月），react 团队开始使用 <strong>learn once, write anywhere</strong> 这个如今我们耳熟能详的口号。</p><h3 id="react-amp-react-dom-amp-babel"><a href="#react-amp-react-dom-amp-babel" class="headerlink" title="react &amp; react-dom &amp; babel"></a>react &amp; react-dom &amp; babel</h3><p>在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:</p><ul><li>官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。</li><li>分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx …</li></ul><p>将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。</p><h3 id="Discontinuing-IE-8-Support"><a href="#Discontinuing-IE-8-Support" class="headerlink" title="Discontinuing IE 8 Support"></a>Discontinuing IE 8 Support</h3><p>在 react V15 的版本中，放弃了对 IE 8 的支持。</p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>react 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。</p><p>到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。</p><h3 id="接下来的展望"><a href="#接下来的展望" class="headerlink" title="接下来的展望"></a>接下来的展望</h3><p>react 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。</p><p>如果你对这方面的内容很感兴趣，不妨看看 react 之前的<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">演讲视频</a></p><h3 id="附录1-一些你可能不知道的变化"><a href="#附录1-一些你可能不知道的变化" class="headerlink" title="附录1 一些你可能不知道的变化"></a>附录1 一些你可能不知道的变化</h3><ul><li>react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考<a href="https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange" target="_blank" rel="noopener">这里</a></li><li>事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8</li><li>react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。</li></ul><h3 id="附录2-一些比较优秀的博客"><a href="#附录2-一些比较优秀的博客" class="headerlink" title="附录2 一些比较优秀的博客"></a>附录2 一些比较优秀的博客</h3><ul><li>关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">React Components, Elements, and Instances</a></li><li>如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a></li><li>react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">You Probably Don’t Need Derived State</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十条编写优化的 JavaScript 代码的建议</title>
      <link href="/2018/05/29/%E5%8D%81%E6%9D%A1%E7%BC%96%E5%86%99%E4%BC%98%E5%8C%96%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
      <url>/2018/05/29/%E5%8D%81%E6%9D%A1%E7%BC%96%E5%86%99%E4%BC%98%E5%8C%96%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：</p><p>1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类</span></span><br></pre></td></tr></table></figure><p>2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  </p><p>3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  </p><p>4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  </p><p>5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  </p><p>6.检查你的依赖，去掉不需要 import 的内容。  </p><p>7.将你的代码分割成一些小的 chunks ，而不是整个引入。 </p><p>8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。</p><p>9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  </p><p>10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  </p><p>以上内容来源：</p><ul><li><a href="https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8" target="_blank" rel="noopener">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈前端中的二进制数据类型</title>
      <link href="/2018/05/09/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/09/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p></blockquote><p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href="http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4" target="_blank" rel="noopener">这里</a>而非本人原创，仅做个人学习使用。</p><p>这些类型化对象，一般会在以下场景中使用：</p><ul><li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li><li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li><li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li><li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li><li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li></ul><p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p><h3 id="二进制数据类型概述"><a href="#二进制数据类型概述" class="headerlink" title="二进制数据类型概述"></a>二进制数据类型概述</h3><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p><p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br></pre></td></tr></table></figure><p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p><p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br><span class="line">var dataView = new DataView(buf);</span><br><span class="line">dataView.getUint8(0) // 0</span><br></pre></td></tr></table></figure><p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p><p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(12);</span><br><span class="line"></span><br><span class="line">var x1 = new Int32Array(buffer);</span><br><span class="line">x1[0] = 1;</span><br><span class="line">var x2 = new Uint8Array(buffer);</span><br><span class="line">x2[0]  = 2;</span><br><span class="line"></span><br><span class="line">x1[0] // 2</span><br></pre></td></tr></table></figure><p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(32);</span><br><span class="line">buffer.byteLength</span><br><span class="line">// 32</span><br></pre></td></tr></table></figure><p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (buffer.byteLength === n) &#123;</span><br><span class="line">  // 成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">var newBuffer = buffer.slice(0, 3);</span><br></pre></td></tr></table></figure><p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p><p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p><p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p><p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">ArrayBuffer.isView(buffer) // false</span><br><span class="line"></span><br><span class="line">var v = new Int32Array(buffer);</span><br><span class="line">ArrayBuffer.isView(v) // true</span><br></pre></td></tr></table></figure><h4 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p><ul><li>Int8Array：8位有符号整数，长度1个字节。</li><li>Uint8Array：8位无符号整数，长度1个字节。</li><li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li><li>Int16Array：16位有符号整数，长度2个字节。</li><li>Uint16Array：16位无符号整数，长度2个字节。</li><li>Int32Array：32位有符号整数，长度4个字节。</li><li>Uint32Array：32位无符号整数，长度4个字节。</li><li>Float32Array：32位浮点数，长度4个字节。</li><li>Float64Array：64位浮点数，长度8个字节。</li></ul><p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p><ul><li>TypedArray数组的所有成员，都是同一种类型和格式。</li><li>TypedArray数组的成员是连续的，不会有空位。</li><li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li><li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li></ul><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p><p>构造函数有多种用法。</p><ul><li>TypedArray(buffer, byteOffset=0, length?)</li></ul><p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个8字节的ArrayBuffer</span><br><span class="line">var b = new ArrayBuffer(8);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span><br><span class="line">var v1 = new Int32Array(b);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span><br><span class="line">var v2 = new Uint8Array(b, 2);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span><br><span class="line">var v3 = new Int16Array(b, 2, 2);</span><br></pre></td></tr></table></figure><p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p><p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">var i16 = new Int16Array(buffer, 1);</span><br><span class="line">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span><br></pre></td></tr></table></figure><p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p><p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p><ul><li>TypedArray(length)</li></ul><p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f64a = new Float64Array(8);</span><br><span class="line">f64a[0] = 10;</span><br><span class="line">f64a[1] = 20;</span><br><span class="line">f64a[2] = f64a[0] + f64a[1];</span><br></pre></td></tr></table></figure><ul><li>TypedArray(typedArray)</li></ul><p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var typedArray = new Int8Array(new Uint8Array(4));</span><br></pre></td></tr></table></figure><p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p><p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = new Int8Array([1, 1]);</span><br><span class="line">var y = new Int8Array(x);</span><br><span class="line">x[0] // 1</span><br><span class="line">y[0] // 1</span><br><span class="line"></span><br><span class="line">x[0] = 2;</span><br><span class="line">y[0] // 1</span><br></pre></td></tr></table></figure><p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p><p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = new Int8Array([1, 1]);</span><br><span class="line">var y = new Int8Array(x.buffer);</span><br><span class="line">x[0] // 1</span><br><span class="line">y[0] // 1</span><br><span class="line"></span><br><span class="line">x[0] = 2;</span><br><span class="line">y[0] // 2</span><br></pre></td></tr></table></figure><ul><li>TypedArray(arrayLikeObject)</li></ul><p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var typedArray = new Uint8Array([1, 2, 3, 4]);</span><br></pre></td></tr></table></figure><p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p><p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p><p>TypedArray数组也可以转换回普通数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var normalArray = Array.prototype.slice.call(typedArray);</span><br></pre></td></tr></table></figure><h5 id="BYTES-PER-ELEMENT属性"><a href="#BYTES-PER-ELEMENT属性" class="headerlink" title="BYTES_PER_ELEMENT属性"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int8Array.BYTES_PER_ELEMENT // 1</span><br><span class="line">Uint8Array.BYTES_PER_ELEMENT // 1</span><br><span class="line">Int16Array.BYTES_PER_ELEMENT // 2</span><br><span class="line">Uint16Array.BYTES_PER_ELEMENT // 2</span><br><span class="line">Int32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Uint32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Float32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Float64Array.BYTES_PER_ELEMENT // 8</span><br></pre></td></tr></table></figure><h5 id="ArrayBuffer与字符串的互相转换"><a href="#ArrayBuffer与字符串的互相转换" class="headerlink" title="ArrayBuffer与字符串的互相转换"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span><br><span class="line">function ab2str(buf) &#123;</span><br><span class="line">  return String.fromCharCode.apply(null, new Uint16Array(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串转为ArrayBuffer对象，参数为字符串</span><br><span class="line">function str2ab(str) &#123;</span><br><span class="line">  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节</span><br><span class="line">  var bufView = new Uint16Array(buf);</span><br><span class="line">  for (var i = 0, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class="line">    bufView[i] = str.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TypedArray-prototype-set"><a href="#TypedArray-prototype-set" class="headerlink" title="TypedArray.prototype.set()"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint8Array(8);</span><br><span class="line">var b = new Uint8Array(8);</span><br><span class="line"></span><br><span class="line">b.set(a);</span><br></pre></td></tr></table></figure><p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint16Array(8);</span><br><span class="line">var b = new Uint16Array(10);</span><br><span class="line"></span><br><span class="line">b.set(a, 2)</span><br></pre></td></tr></table></figure><p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p><h5 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint16Array(8);</span><br><span class="line">var b = a.subarray(2,3);</span><br><span class="line"></span><br><span class="line">a.byteLength // 16</span><br><span class="line">b.byteLength // 2</span><br></pre></td></tr></table></figure><p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p><h5 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ui8 = Uint8Array.of(0, 1, 2);</span><br><span class="line">ui8.slice(-1)</span><br><span class="line">// Uint8Array [ 2 ]</span><br></pre></td></tr></table></figure><p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p><p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p><h5 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Float32Array.of(0.151, -8, 3.7)</span><br><span class="line">// Float32Array [ 0.151, -8, 3.7 ]</span><br></pre></td></tr></table></figure><h5 id="TypedArray-from"><a href="#TypedArray-from" class="headerlink" title="TypedArray.from()"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uint16Array.from([0, 1, 2])</span><br><span class="line">// Uint16Array [ 0, 1, 2 ]</span><br></pre></td></tr></table></figure><p>这个方法还可以将一种TypedArray实例，转为另一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));</span><br><span class="line">ui16 instanceof Uint16Array // true</span><br></pre></td></tr></table></figure><p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Int8Array.of(127, 126, 125).map(x =&gt; 2 * x)</span><br><span class="line">// Int8Array [ -2, -4, -6 ]</span><br><span class="line"></span><br><span class="line">Int16Array.from(Int8Array.of(127, 126, 125), x =&gt; 2 * x)</span><br><span class="line">// Int16Array [ 254, 252, 250 ]</span><br></pre></td></tr></table></figure><p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p><h4 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p><p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p><p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(24);</span><br><span class="line">var dv = new DataView(buffer);</span><br></pre></td></tr></table></figure><p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p><ul><li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li><li>DataView.prototype.byteLength：返回占据的内存字节长度</li><li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li></ul><p>DataView实例提供8个方法读取内存。</p><ul><li>getInt8：读取1个字节，返回一个8位整数。</li><li>getUint8：读取1个字节，返回一个无符号的8位整数。</li><li>getInt16：读取2个字节，返回一个16位整数。</li><li>getUint16：读取2个字节，返回一个无符号的16位整数。</li><li>getInt32：读取4个字节，返回一个32位整数。</li><li>getUint32：读取4个字节，返回一个无符号的32位整数。</li><li>getFloat32：读取4个字节，返回一个32位浮点数。</li><li>getFloat64：读取8个字节，返回一个64位浮点数。</li></ul><p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(24);</span><br><span class="line">var dv = new DataView(buffer);</span><br><span class="line"></span><br><span class="line">// 从第1个字节读取一个8位无符号整数</span><br><span class="line">var v1 = dv.getUint8(0);</span><br><span class="line"></span><br><span class="line">// 从第2个字节读取一个16位无符号整数</span><br><span class="line">var v2 = dv.getUint16(1);</span><br><span class="line"></span><br><span class="line">// 从第4个字节读取一个16位无符号整数</span><br><span class="line">var v3 = dv.getUint16(3);</span><br></pre></td></tr></table></figure><p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p><p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 小端字节序</span><br><span class="line">var v1 = dv.getUint16(1, true);</span><br><span class="line"></span><br><span class="line">// 大端字节序</span><br><span class="line">var v2 = dv.getUint16(3, false);</span><br><span class="line"></span><br><span class="line">// 大端字节序</span><br><span class="line">var v3 = dv.getUint16(3);</span><br></pre></td></tr></table></figure><p>DataView视图提供8个方法写入内存。</p><ul><li>setInt8：写入1个字节的8位整数。</li><li>setUint8：写入1个字节的8位无符号整数。</li><li>setInt16：写入2个字节的16位整数。</li><li>setUint16：写入2个字节的16位无符号整数。</li><li>setInt32：写入4个字节的32位整数。</li><li>setUint32：写入4个字节的32位无符号整数。</li><li>setFloat32：写入4个字节的32位浮点数。</li><li>setFloat64：写入8个字节的64位浮点数。</li></ul><p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在第1个字节，以大端字节序写入值为25的32位整数</span><br><span class="line">dv.setInt32(0, 25, false);</span><br><span class="line"></span><br><span class="line">// 在第5个字节，以大端字节序写入值为25的32位整数</span><br><span class="line">dv.setInt32(4, 25);</span><br><span class="line"></span><br><span class="line">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span><br><span class="line">dv.setFloat32(8, 2.5, true);</span><br></pre></td></tr></table></figure><p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var littleEndian = (function() &#123;</span><br><span class="line">  var buffer = new ArrayBuffer(2);</span><br><span class="line">  new DataView(buffer).setInt16(0, 256, true);</span><br><span class="line">  return new Int16Array(buffer)[0] === 256;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p><p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();</span><br><span class="line">reader.addEventListener(&quot;loadend&quot;, function() &#123;</span><br><span class="line">   // reader.result 包含转化为类型数组的blob</span><br><span class="line">&#125;);</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure><p>更多关于Blob的内容，请直接查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">这里</a></p><h3 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h3><h4 id="String转Blob"><a href="#String转Blob" class="headerlink" title="String转Blob"></a>String转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将字符串 转换成 Blob 对象</span><br><span class="line">var blob = new Blob([&quot;Hello World!&quot;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.info(blob);</span><br><span class="line">console.info(blob.slice(1, 3, &apos;text/plain&apos;));</span><br></pre></td></tr></table></figure><h4 id="TypeArray转Blob"><a href="#TypeArray转Blob" class="headerlink" title="TypeArray转Blob"></a>TypeArray转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//将 TypeArray  转换成 Blob 对象</span><br><span class="line">var array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);</span><br><span class="line">//测试成功</span><br><span class="line">//var blob = new Blob([array], &#123; type: &quot;application/octet-binary&quot; &#125;);</span><br><span class="line">//测试成功， 注意必须[]的包裹</span><br><span class="line">var blob = new Blob([array]);</span><br><span class="line">//将 Blob对象 读成字符串</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsText(blob, &apos;utf-8&apos;);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result); //a Hello world!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayBuffer转Blob"><a href="#ArrayBuffer转Blob" class="headerlink" title="ArrayBuffer转Blob"></a>ArrayBuffer转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(32);</span><br><span class="line">var blob = new Blob([buffer]);       // 注意必须包裹[]</span><br></pre></td></tr></table></figure><h4 id="Blob转String"><a href="#Blob转String" class="headerlink" title="Blob转String"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将字符串转换成 Blob对象</span><br><span class="line">var blob = new Blob([&apos;中文字符串&apos;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">//将Blob 对象转换成字符串</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsText(blob, &apos;utf-8&apos;);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Blob转ArrayBuffer"><a href="#Blob转ArrayBuffer" class="headerlink" title="Blob转ArrayBuffer"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//将字符串转换成 Blob对象</span><br><span class="line">var blob = new Blob([&apos;中文字符串&apos;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">//将Blob 对象转换成 ArrayBuffer</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result); //ArrayBuffer &#123;&#125;</span><br><span class="line">    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span><br><span class="line">    //var buf = new int16array(reader.result);</span><br><span class="line">    //console.info(buf);</span><br><span class="line"></span><br><span class="line">    //将 ArrayBufferView  转换成Blob</span><br><span class="line">    var buf = new Uint8Array(reader.result);</span><br><span class="line">    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span><br><span class="line">    reader.readAsText(new Blob([buf]), &apos;utf-8&apos;);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        console.info(reader.result); //中文字符串</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //将 ArrayBufferView  转换成Blob</span><br><span class="line">    var buf = new DataView(reader.result);</span><br><span class="line">    console.info(buf); //DataView &#123;&#125;</span><br><span class="line">    reader.readAsText(new Blob([buf]), &apos;utf-8&apos;);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        console.info(reader.result); //中文字符串</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux服务器初始化设置用户和ssh公私钥登陆</title>
      <link href="/2018/04/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/"/>
      <url>/2018/04/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。</p></blockquote><h3 id="修改ssh端口号"><a href="#修改ssh端口号" class="headerlink" title="修改ssh端口号"></a>修改ssh端口号</h3><p>第一件事情：</p><p>修改ssh端口号： 之后加上一个端口比如说50000</p><p><code>vi /etc/ssh/sshd_config</code>之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。</p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考<a href="https://blog.csdn.net/ul646691993/article/details/52104082" target="_blank" rel="noopener">这里</a>的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。</p><p>之后就可以通过这样的方式登录了：(注意登录方式一定要写对)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@115.29.102.81 -p 50000</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaotao</span><br><span class="line">passwd xiaotao</span><br></pre></td></tr></table></figure><p>可以用<code>ls -al /home/`</code>查看一下账户</p><p>对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w sudoers</span><br></pre></td></tr></table></figure><p>然后进入这个文件在这里进行更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">xiaotao  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>然后再改回权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-w sudoers</span><br></pre></td></tr></table></figure><p>注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><h3 id="配置公私钥加密登录"><a href="#配置公私钥加密登录" class="headerlink" title="配置公私钥加密登录"></a>配置公私钥加密登录</h3><p><strong>这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。</strong></p><p>很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。</p><p>在客户端先进到这个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>生成公钥和私钥（实际上如果之前有的话就不用重新生成了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>接下来把公钥上传到服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub xiaotao@&lt;ssh_server_ip&gt;:~</span><br></pre></td></tr></table></figure><p>在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  id_rsa.pub &gt;&gt; ～/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"># 禁用root账户登录，非必要，但为了安全性，请配置</span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"># 是否让 sshd 去检查用户家目录或相关档案的权限数据，</span><br><span class="line"># 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。</span><br><span class="line"># 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入</span><br><span class="line">StrictModes no</span><br><span class="line"></span><br><span class="line"># 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。</span><br><span class="line"># 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">#有了证书登录了，就禁用密码登录吧，安全要紧</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>然后不要忘记 <code>sudo service sshd restart</code></p><p>一般来讲，这样就算是成功了，我们可以在客户端尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa remote_username@remote_ip</span><br></pre></td></tr></table></figure><p>如果不行，可能是服务端或客户端相关 <code>.ssh</code> 文件权限不对，可以进行如下尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务端</span><br><span class="line">chown -R 0700  ~/.ssh</span><br><span class="line">chown -R 0644  ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">客户端改一下</span><br><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dva源码解读</title>
      <link href="/2018/04/11/dva%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2018/04/11/dva%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本文章用于个人学习研究，并不代表 dva 团队的任何观点。</p><p>原文以及包含一定注释的代码见<a href="https://github.com/aircloud/dva-analysis" target="_blank" rel="noopener">这里</a>，若有问题也可以在<a href="https://github.com/aircloud/dva-analysis/issues" target="_blank" rel="noopener">这里</a>进行讨论</p><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="为什么是dva"><a href="#为什么是dva" class="headerlink" title="为什么是dva?"></a>为什么是dva?</h4><p>笔者对 dva 的源代码进行解读，主要考虑到 dva 并不是一个和我们熟知的主流技术无关的从0到1的框架，相反，它是对主流技术进行整合，提炼，从而形成一种最佳实践，分析 dva，意味着我们可以对自己掌握的很多相关技术进行回顾，另外，dva 的代码量并不多，也不至于晦涩难懂，可以给我们平时的业务开发以启发。</p><p>本文章作为 dva 的源码解读文章，并不面向新手用户，读者应当有一定的 react 使用经验和 ECMAscript 2015+ 的使用经验，并且应当了解 redux 和 redux-saga，以及对 dva 的使用有所了解(可以从<a href="https://github.com/dvajs/dva/blob/master/README_zh-CN.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dva-" target="_blank" rel="noopener">这里</a>了解为什么需要使用 dva)</p><p>重点推荐:</p><ul><li>通过<a href="https://github.com/dvajs/dva-knowledgemap" target="_blank" rel="noopener">这里</a>的内容了解使用dva的最小知识集</li><li>通过<a href="https://redux-saga-in-chinese.js.org/docs/introduction/index.html" target="_blank" rel="noopener">这里</a>学习 redux-saga</li></ul><p>其他推荐：</p><ul><li><a href="https://github.com/dvajs/dva/blob/master/docs/Concepts_zh-CN.md" target="_blank" rel="noopener">dva的概念</a></li><li><a href="https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md" target="_blank" rel="noopener">dva的全部API</a></li><li><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="noopener">React+Redux 最佳实践</a></li><li><a href="http://slides.com/sorrycc/dva#/" target="_blank" rel="noopener">React在蚂蚁金服的实践</a></li><li><a href="https://github.com/sorrycc/blog/issues/48" target="_blank" rel="noopener">dva 2.0的改进</a></li><li><a href="http://cn.redux.js.org/docs/recipes/ComputingDerivedData.html" target="_blank" rel="noopener">ReSelect介绍</a></li><li><a href="https://www.jianshu.com/p/04d3fefea8d7" target="_blank" rel="noopener">浅析Redux 的 store enhancer</a></li></ul><p>几个 dva 版本之间的关系:</p><ul><li><a href="mailto:dva@2.0" target="_blank" rel="noopener">dva@2.0</a>：基于 react 和 react-router@4</li><li><a href="mailto:dva-react-router-3@1.0" target="_blank" rel="noopener">dva-react-router-3@1.0</a>：基于 react 和 react-router@3</li><li><a href="mailto:dva-no-router@1.0" target="_blank" rel="noopener">dva-no-router@1.0</a>：无路由版本，适用于多页面场景，可以和 next.js 组合使用</li><li><a href="mailto:dva-core@1.0" target="_blank" rel="noopener">dva-core@1.0</a>：仅封装了 redux 和 redux-saga</li></ul><p>我们本次主要分析目标为 <a href="mailto:dva@2.0" target="_blank" rel="noopener">dva@2.0</a> 和 <a href="mailto:dva-core@1.0" target="_blank" rel="noopener">dva-core@1.0</a></p><h3 id="我们为什么需要-redux-saga"><a href="#我们为什么需要-redux-saga" class="headerlink" title="我们为什么需要 redux-saga"></a>我们为什么需要 redux-saga</h3><p>目前，在大多数项目开发中，我们现在依然采用的是redux-thunk + async/await (或 Promise)。</p><p>实际上这个十几行的插件已经完全可以解决大多是场景下的问题了，如果你在目前的工作中正在使用这一套方案并且能够完全将当下的需求应付自如并且没有什么凌乱的地方，其实也是没有必要换成redux-saga的。</p><p>接下来我们讲 redux-saga，先看名字：saga，这个术语常用于CQRS架构，代表查询与责任分离。</p><p>相比于 redux-thunk，前者通常是把数据查询等请求放在 actions 中(不纯净的 actions)，并且这些 actions 可以继续回调调用其他 actions(纯净的 actions)，从而完成数据的更新；而 redux-saga，则保持了 actions 的纯粹性，单独抽出一层专门来处理数据请求等操作(saga函数)。</p><p>这样做还有另外一些好处：</p><ul><li>由于我们已经将数据处理数据请求等异步操作抽离出来了，并且通过 generator 来处理，我们便可以方便地进行多种异步管理：比如同时按顺序执行多个任务、在多个异步任务中启动race等。</li><li>这样做可以延长任务的生命周期，我们的一次调用可以不再是一个”调完即走”的过程，还可以是一个LLT（Long Lived Transaction)的事物处理过程，比如我们可以将用户的登入、登出的管理放在一个saga函数中处理。</li></ul><p>当然，redux-saga还有比如拥有有诸多常用并且声明式易测的 Effects、可以无阻塞的fork等一些更复杂的异步操作和管理方法，如果应用中有较多复杂的异步操作流程，使用redux-saga无疑会让条理更加清楚。</p><p>当然，本文的目的不是介绍或者安利redux-saga，只是因为redux-saga是 dva 的一个基础，相关概念点到为止，如需了解更多请自行参考资料。</p><h3 id="dva-源码解读"><a href="#dva-源码解读" class="headerlink" title="dva 源码解读"></a>dva 源码解读</h3><p>我们的源码分析流程是这样的：通过一个使用 dva 开发的例子，随着其对 dva 函数的逐步调用，来分析内部 dva 相关函数的实现原理。</p><p>我们分析采用的例子是 dva 官方提供的一个增删改查的应用，可以在<a href="https://github.com/dvajs/dva/tree/rewrite-dynamic" target="_blank" rel="noopener">这里</a>找到它的源代码。</p><p>我们先看该例子的入口文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import dva from &apos;dva&apos;;</span><br><span class="line">import createHistory from &apos;history/createBrowserHistory&apos;;</span><br><span class="line">import createLoading from &apos;dva-loading&apos;;</span><br><span class="line">import &#123; message &#125; from &apos;antd&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line"></span><br><span class="line">const ERROR_MSG_DURATION = 3; // 3 秒</span><br><span class="line"></span><br><span class="line">// 1. Initialize</span><br><span class="line">const app = dva(&#123;</span><br><span class="line">  history: createHistory(),</span><br><span class="line">  onError(e) &#123;</span><br><span class="line">    message.error(e.message, ERROR_MSG_DURATION);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2. Plugins</span><br><span class="line">app.use(createLoading());</span><br><span class="line"></span><br><span class="line">// 3. Model</span><br><span class="line">// Moved to router.js</span><br><span class="line">// 这里的 Model 被转移到了动态加载的 router 里面，我们也可以如下写：</span><br><span class="line">// app.model(require(&apos;./models/users&apos;));</span><br><span class="line"></span><br><span class="line">// 4. Router</span><br><span class="line">app.router(require(&apos;./router&apos;));</span><br><span class="line"></span><br><span class="line">// 5. Start</span><br><span class="line">app.start(&apos;#root&apos;);</span><br></pre></td></tr></table></figure><p>我们发现dva从初始化配置到最后的start(现在的dva start函数在不传入container的情况下可以返回React Component，便于服务端渲染等，但这里我们还是按照例子的写法来)。</p><p>这里我们先有必要解释一下，dva 在当前依据能力和依赖版本的不同，有多个可引入的版本，我们的例子和所要分析的源代码都是基于 react-router V4 的 dva 版本。</p><p>在源代码中，相关目录主要为 dva 目录(packages/dva) 和 dva-core(packages/dva-core)目录，前者主要拥有history管理、router、动态加载等功能，而后者是不依赖这些内容的基础模块部分，为前者所引用</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>第一步这里传入了两个内容：(dva构造函数总共可以传入那些 opts，会在下文中进行说明)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const app = dva(&#123;</span><br><span class="line">  history: createHistory(),</span><br><span class="line">  onError(e) &#123;</span><br><span class="line">    message.error(e.message, ERROR_MSG_DURATION);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这一步的相关核心代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default function (opts = &#123;&#125;) &#123;</span><br><span class="line">  const history = opts.history || createHashHistory(); // 默认为 HashHistory</span><br><span class="line">  const createOpts = &#123;</span><br><span class="line">    initialReducer: &#123;</span><br><span class="line">      routing, // 来自 react-router-redux 的 routerReducer</span><br><span class="line">    &#125;,</span><br><span class="line">    setupMiddlewares(middlewares) &#123;</span><br><span class="line">      return [</span><br><span class="line">        routerMiddleware(history), // 来自 react-router-redux 的 routerMiddleware</span><br><span class="line">        ...middlewares,</span><br><span class="line">      ];</span><br><span class="line">    &#125;,</span><br><span class="line">    setupApp(app) &#123;</span><br><span class="line">      app._history = patchHistory(history); </span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const app = core.create(opts, createOpts);</span><br><span class="line">  const oldAppStart = app.start;</span><br><span class="line">  app.router = router;</span><br><span class="line">  app.start = start;</span><br><span class="line">  return app;</span><br><span class="line">  </span><br><span class="line">  // 一些用到的函数的定义...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面大多数内容都比较简单，这里面提两个地方：</p><ol><li>patchHistory：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function patchHistory(history) &#123;</span><br><span class="line">  const oldListen = history.listen;</span><br><span class="line">  history.listen = (callback) =&gt; &#123;</span><br><span class="line">    callback(history.location);</span><br><span class="line">    return oldListen.call(history, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  return history;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里的意思是让第一次被绑定 listener 的时候执行一遍 callback，可以用于初始化相关操作。</p><p>我们可以在<code>router.js</code>中添加如下代码来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.listen((location, action)=&gt;&#123;</span><br><span class="line">  console.log(&apos;history listen:&apos;, location, action)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在完成可选项的构造之后，调用了 dva-core 中暴露的 create 函数。</li></ol><p>create 函数本身也并不复杂，核心代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">hooksAndOpts = &#123;&#125;, createOpts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    initialReducer,</span><br><span class="line">    setupApp = noop,</span><br><span class="line">  &#125; = createOpts;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> plugin = <span class="keyword">new</span> Plugin(); <span class="comment">// 实例化钩子函数管理类</span></span><br><span class="line">  plugin.use(filterHooks(hooksAndOpts)); <span class="comment">// 这个时候先对 obj 进行清理，清理出在我们定义的类型之外的 hooks，之后进行统一绑定</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = &#123;</span><br><span class="line">    _models: [</span><br><span class="line">      prefixNamespace(&#123; ...dvaModel &#125;), <span class="comment">// 前缀处理</span></span><br><span class="line">    ],</span><br><span class="line">    _store: <span class="literal">null</span>,</span><br><span class="line">    _plugin: plugin,</span><br><span class="line">    use: plugin.use.bind(plugin),</span><br><span class="line">    model, <span class="comment">// 下文定义</span></span><br><span class="line">    start, <span class="comment">// 下文定义</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//一些函数的定义</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以看到，这里的 <code>hooksAndOpts</code> 实际上就是一开始我们构造 dva 的时候传入的 opts 对象经过处理之后的结果。</p><p>我们可以传入的可选项，实际上都在 <code>Plugin.js</code> 中写明了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const hooks = [</span><br><span class="line">  &apos;onError&apos;,</span><br><span class="line">  &apos;onStateChange&apos;,</span><br><span class="line">  &apos;onAction&apos;,</span><br><span class="line">  &apos;onHmr&apos;,</span><br><span class="line">  &apos;onReducer&apos;,</span><br><span class="line">  &apos;onEffect&apos;,</span><br><span class="line">  &apos;extraReducers&apos;,</span><br><span class="line">  &apos;extraEnhancers&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>具体 <a href="https://github.com/dvajs/dva/blob/master/docs/API_zh-CN.md#appusehooks" target="_blank" rel="noopener">hooks的作用可以在这里进行查阅</a>。</p><p>Plugin 插件管理类(实际上我认为称其为钩子函数管理类比较合适)除了定义了上文的使用到的use方法(挂载插件)、还有apply方法(执行某一个钩子下挂载的所有回调)、get方法(获取某一个钩子下的所有回调，返回数组)</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>这里的第二步比较简洁：我们知道实际上这里就是使用了<code>plugin.use</code>方法挂载了一个插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(createLoading()); <span class="comment">// 需要注意，插件挂载需要在 app.start 之前</span></span><br></pre></td></tr></table></figure><p>createLoading 这个插件实际上是官方提供的 Loading 插件，通过这个插件我们可以非常方便地进行 Loading 的管理，无需进行手动管理，我们可以先<a href="https://www.jianshu.com/p/61fe7a57fad4" target="_blank" rel="noopener">看一篇文章</a>来简单了解一下。</p><p>这个插件看似神奇，实际上原理也比较简单，主要用了<code>onEffect</code>钩子函数(装饰器)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onEffect</span>(<span class="params">effect, &#123; put &#125;, model, actionType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; namespace &#125; = model;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (only.length === <span class="number">0</span> &amp;&amp; except.length === <span class="number">0</span>)</span><br><span class="line">        || (only.length &gt; <span class="number">0</span> &amp;&amp; only.indexOf(actionType) !== <span class="number">-1</span>)</span><br><span class="line">        || (except.length &gt; <span class="number">0</span> &amp;&amp; except.indexOf(actionType) === <span class="number">-1</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: SHOW, <span class="attr">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class="line">            <span class="keyword">yield</span> effect(...args);</span><br><span class="line">            <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: HIDE, <span class="attr">payload</span>: &#123; namespace, actionType &#125; &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结合基于的redux-saga，在目标异步调用开始的时候<code>yield put({ type: SHOW, payload: { namespace, actionType } });</code>，在异步调用结束的时候<code>yield put({ type: HIDE, payload: { namespace, actionType } });</code>，这样就可以管理异步调用开始和结束的Loading状态了。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>第三步这里其实省略了，因为使用了动态加载，将 Models 定义的内容和 React Component 进行了动态加载，实际上也可以按照注释的方法来写。</p><p>但是没有关系，我们还是可以分析 models 引入的文件中做了哪些事情(下面列出的代码在原基础上进行了一些简化):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queryString <span class="keyword">from</span> <span class="string">'query-string'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> usersService <span class="keyword">from</span> <span class="string">'../services/users'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'users'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: <span class="literal">null</span>,</span><br><span class="line">    page: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    save(state, &#123; <span class="attr">payload</span>: &#123; <span class="attr">data</span>: list, total, page &#125; &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list, total, page &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *fetch(&#123; <span class="attr">payload</span>: &#123; page = <span class="number">1</span> &#125; &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data, headers &#125; = <span class="keyword">yield</span> call(usersService.fetch, &#123; page &#125;);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'save'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          data,</span><br><span class="line">          total: <span class="built_in">parseInt</span>(headers[<span class="string">'x-total-count'</span>], <span class="number">10</span>),</span><br><span class="line">          page: <span class="built_in">parseInt</span>(page, <span class="number">10</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    *reload(action, &#123; put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> page = <span class="keyword">yield</span> select(<span class="function"><span class="params">state</span> =&gt;</span> state.users.page);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: &#123; page &#125; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname, search &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> query = queryString.parse(search);</span><br><span class="line">        <span class="keyword">if</span> (pathname === <span class="string">'/users'</span>) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: query &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些内容，我们通过<code>app.model(require(&#39;./models/users&#39;));</code>就可以引入。</p><p>实际上，model 函数本身还是比较简单的，但由于 dva 拥有 model 动态加载的能力，实际上调用 app.start 前和 app.start 后model函数是不一样的。</p><p>调用 start 函数前，我们直接挂载即可(因为start函数中会对所有model进行遍历性统一处理，所以无需过多处理)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">model</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkModel(m, app._models);</span><br><span class="line">    &#125;</span><br><span class="line">    app._models.push(prefixNamespace(m));</span><br><span class="line">    <span class="comment">// 把 model 注册到 app 的 _models 里面，但是当 app start 之后，就不能仅仅用这种方法了，需要 injectModel</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用了 start 函数之后，model函数被替换成如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectModel</span>(<span class="params">createReducer, onError, unlisteners, m</span>) </span>&#123;</span><br><span class="line">    model(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = app._store;</span><br><span class="line">    <span class="keyword">if</span> (m.reducers) &#123;</span><br><span class="line">      store.asyncReducers[m.namespace] = getReducer(m.reducers, m.state);</span><br><span class="line">      store.replaceReducer(createReducer(store.asyncReducers));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.effects) &#123;</span><br><span class="line">      store.runSaga(app._getSaga(m.effects, m, onError, plugin.get(<span class="string">'onEffect'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.subscriptions) &#123;</span><br><span class="line">      unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>我们首先分析第一个 if 中的内容</strong>：首先通过getReducer函数将转换好的 reducers 挂载(或替换)到 store.asyncReducers[m.namespace] 中，然后通过 redux 本身提供的能力 replaceReducer 完成 reducer 的替换。</p><p>这里我们需要注意 getReducer 函数，实际上，dva 里面 reducers 写法和我们之前直接使用 redux 的写法略有不同：</p><p>我们这里的 reducers，实际上要和 action 中的 actionType 同名的 reducer，所以这里我们没有必要去写 switch case 了，对于某一个 reducer 来说其行为应该是确定的，这给 reducers 的写法带来了一定的简化，当然，我们可以使用 extraReducers 定义我们之前习惯的那种比较复杂的 reducers。</p><p><strong>接下来我们分析第二个 if 中的内容</strong>：第二个函数首先获取到了我们定义的 effects 并通过 _getSaga 进行处理，然后使用 <code>runSaga</code>(实际上就是createSagaMiddleware().run，来自于redux-saga) 进行执行。</p><p>实际上，这里的 <code>_getSaga</code> 函数比较复杂，我们接下来重点介绍这个函数。</p><p><code>_getSaga</code> 函数由 <code>getSaga.js</code> 暴露，其定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getSaga</span>(<span class="params">resolve, reject, effects, model, onError, onEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;  <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> effects) &#123;  <span class="comment">// 这个函数对 effects 里面的所有键</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(effects, key)) &#123; <span class="comment">// 先判断一下键是属于自己的</span></span><br><span class="line">        <span class="keyword">const</span> watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);</span><br><span class="line">        <span class="comment">// 然后调用getWatch获取watcher</span></span><br><span class="line">        <span class="keyword">const</span> task = <span class="keyword">yield</span> sagaEffects.fork(watcher); <span class="comment">// 利用 fork 开启一个 task</span></span><br><span class="line">        <span class="keyword">yield</span> sagaEffects.fork(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123; <span class="comment">// 这样写的目的是，如果我们移除了这个 model 要及时结束掉</span></span><br><span class="line">          <span class="keyword">yield</span> sagaEffects.take(<span class="string">`<span class="subst">$&#123;model.namespace&#125;</span>/@@CANCEL_EFFECTS`</span>);</span><br><span class="line">          <span class="keyword">yield</span> sagaEffects.cancel(task);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getWatcher 的一些核心代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWatcher</span>(<span class="params">resolve, reject, key, _effect, model, onError, onEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> effect = _effect;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="string">'takeEvery'</span>;</span><br><span class="line">  <span class="keyword">let</span> ms;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(_effect)) &#123;</span><br><span class="line">    effect = _effect[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> opts = _effect[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 对 opts 进行一定的校验</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> *<span class="title">sagaWithCatch</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// 都会调用这个过程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> sagaEffects.put(&#123; <span class="attr">type</span>: <span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;NAMESPACE_SEP&#125;</span>@@start`</span> &#125;);</span><br><span class="line">      <span class="keyword">const</span> ret = <span class="keyword">yield</span> effect(...args.concat(createEffects(model)));</span><br><span class="line">      <span class="keyword">yield</span> sagaEffects.put(&#123; <span class="attr">type</span>: <span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;NAMESPACE_SEP&#125;</span>@@end`</span> &#125;);</span><br><span class="line">      resolve(key, ret);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      onError(e);</span><br><span class="line">      <span class="keyword">if</span> (!e._dontReject) &#123;</span><br><span class="line">        reject(key, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); </span><br><span class="line">  <span class="comment">// 挂载 onEffect 钩子</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'watcher'</span>:</span><br><span class="line">      <span class="keyword">return</span> sagaWithCatch;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'takeLatest'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> takeLatest(key, sagaWithOnEffect);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'throttle'</span>: <span class="comment">// 起到节流的效果，在 ms 时间内仅仅会被触发一次</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> throttle(ms, key, sagaWithOnEffect);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> takeEvery(key, sagaWithOnEffect);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的工作，可以主要分为以下三个部分：</p><p>1.将 effect 包裹成 sagaWithCatch，除了便于错误处理和增加前后钩子，值得我们注意的是 resolve 和 reject，</p><p>这个 resolve 和 reject，实际上是来自<code>createPromiseMiddleware.js</code></p><p>我们知道，我们在使用redux-saga的过程中，实际上是监听未来的action，并执行 effects，所以我们在一个 effects 函数中执行一些异步操作，然后 put(dispatch) 一个 action，还是会被监听这个 action 的其他 saga 监听到。</p><p>所以就有如下场景：我们 dispatch 一个 action，这个时候如果我们想获取到什么时候监听这个 action 的 saga 中的异步操作执行结束，是办不到的(因为不是所有的时候我们都把所有处理逻辑写在 saga 中)，所以我们的 dispatch 有的时候需要返回一个 Promise 从而我们可以进行异步结束后的回调(这个 Promise 在监听者 saga 异步执行完后被决议，见上文<code>sagaWithCatch</code>函数源代码)。</p><p>如果我讲的还是比较混乱，也可以参考<a href="https://github.com/dvajs/dva/issues/175" target="_blank" rel="noopener">这个issue</a></p><p>对于这个情况，我认为这是 dva 代码最精彩的地方之一，作者通过定义如下的middleware:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = <span class="function"><span class="params">()</span> =&gt;</span> next =&gt; <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; type &#125; = action;</span><br><span class="line">   <span class="keyword">if</span> (isEffect(type)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       map[type] = &#123;</span><br><span class="line">         resolve: wrapped.bind(<span class="literal">null</span>, type, resolve),</span><br><span class="line">         reject: wrapped.bind(<span class="literal">null</span>, type, reject),</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> next(action);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">wrapped</span>(<span class="params">type, fn, args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (map[type]) <span class="keyword">delete</span> map[type];</span><br><span class="line">   fn(args);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">type, args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (map[type]) &#123;</span><br><span class="line">     map[type].resolve(args);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">type, args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (map[type]) &#123;</span><br><span class="line">     map[type].reject(args);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>并且在上文的<code>sagaWithCatch</code>相关effect执行结束的时候调用 resolve，让 dispatch 返回了一个 Promise。</p><p>当然，上面这段代码还是有点问题的，这样会导致同名 reducer 和 effect 不会 fallthrough（即两者都执行），因为都已经返回了，action 便不会再进一步传递，关于这样设计的好坏，在<a href="https://github.com/sorrycc/blog/issues/48" target="_blank" rel="noopener">这里</a>有过一些讨论，笔者不进行展开表述。</p><p>2.在上面冗长的第一步之后，又通过<code>applyOnEffect</code>函数包裹了<code>OnEffect</code>的钩子函数，这相当于是一种<code>compose</code>，(上文的 dva-loading 中间件实际上就是在这里被处理的)其实现对于熟悉 redux 的同学来说应该不难理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyOnEffect</span>(<span class="params">fns, effect, model, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">    effect = fn(effect, sagaEffects, model, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后，根据我们定义的type(默认是<code>takeEvery</code>，也就是都执行)，来选择不同的 saga，takeLatest 即为只是执行最近的一个，throttle则起到节流的效果，一定时间内仅仅允许被触发一次，这些都是 redux-saga 的内部实现，dva 也是基本直接引用，因此在这里不进行展开。</p><p><strong>最后我们分析<code>injectModel</code>第三个<code>if</code>中的内容</strong>:处理<code>subscriptions</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.subscriptions) &#123;</span><br><span class="line">  unlisteners[m.namespace] = runSubscription(m.subscriptions, m, app, onError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>subscriptions</code>可以理解为和这个model有关的全局监听，但是相对独立。这一个步骤首先调用<code>runSubscription</code>来一个一个调用我们的<code>subscriptions</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">subs, model, app, onError</span>) </span>&#123; <span class="comment">// 在index.js中被重命名为 runSubscription</span></span><br><span class="line">  <span class="keyword">const</span> funcs = [];</span><br><span class="line">  <span class="keyword">const</span> nonFuncs = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> subs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(subs, key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs[key];</span><br><span class="line">      <span class="keyword">const</span> unlistener = sub(&#123;</span><br><span class="line">        dispatch: prefixedDispatch(app._store.dispatch, model),</span><br><span class="line">        history: app._history,</span><br><span class="line">      &#125;, onError);</span><br><span class="line">      <span class="keyword">if</span> (isFunction(unlistener)) &#123;</span><br><span class="line">        funcs.push(unlistener);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nonFuncs.push(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; funcs, nonFuncs &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们所期待的，<code>run</code>函数就是一个一个执行<code>subscriptions</code>，但是这里有一点需要我们注意的，我们定义的<code>subscriptions</code>应该是需要返回一个<code>unlistener</code>来返回接触函数，这样当整个 model 被卸载的时候 dva 会自动调用这个接解除函数(也就是为什么这里的返回函数被命名为<code>unlistener</code>)</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>源代码中的第四步，是对 router 的挂载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router(<span class="built_in">require</span>(<span class="string">'./router'</span>));</span><br></pre></td></tr></table></figure><p><code>require(&#39;./router&#39;)</code>返回的内容在源代码中经过一系列引用传递最后直接被构造成 React Component 并且最终调用 ReactDom.render 进行渲染，这里没有什么好说的，值得一提的就是 router 的动态加载。</p><p>动态加载在该样例中是这样使用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Switch, Route &#125; <span class="keyword">from</span> <span class="string">'dva/router'</span>;</span><br><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'dva/dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RouterConfig</span>(<span class="params">&#123; history, app &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> IndexPage = dynamic(&#123;</span><br><span class="line">    app,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/IndexPage'</span>),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Users = dynamic(&#123;</span><br><span class="line">    app,</span><br><span class="line">    models: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./models/users'</span>),</span><br><span class="line">    ],</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/Users'</span>),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  history.listen(<span class="function">(<span class="params">location, action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'history listen:'</span>, location, action)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route exact path=<span class="string">"/"</span> component=&#123;IndexPage&#125; /&gt;</span><br><span class="line">        &lt;Route exact path=<span class="string">"/users"</span> component=&#123;Users&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，主要就是利用<code>dva/dynamic.js</code>暴露的 dynamic 函数进行动态加载，接下来我们简单看一下 dynamic 函数做了什么:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">dynamic</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app, <span class="attr">models</span>: resolveModels, <span class="attr">component</span>: resolveComponent &#125; = config;</span><br><span class="line">  <span class="keyword">return</span> asyncComponent(&#123;</span><br><span class="line">    resolve: config.resolve || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> models = <span class="keyword">typeof</span> resolveModels === <span class="string">'function'</span> ? resolveModels() : [];</span><br><span class="line">      <span class="keyword">const</span> component = resolveComponent();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all([...models, component]).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!models || !models.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(ret[<span class="number">0</span>]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> len = models.length;</span><br><span class="line">            ret.slice(<span class="number">0</span>, len).forEach(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">              m = m.default || m;</span><br><span class="line">              <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(m)) &#123;</span><br><span class="line">                m = [m];</span><br><span class="line">              &#125;</span><br><span class="line">              m.map(<span class="function"><span class="params">_</span> =&gt;</span> registerModel(app, _)); <span class="comment">// 注册所有的 model</span></span><br><span class="line">            &#125;);</span><br><span class="line">            resolve(ret[len]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...config,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要调用了 asyncComponent 函数，接下来我们再看一下这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; resolve &#125; = config;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">      <span class="keyword">super</span>(...args);</span><br><span class="line">      <span class="keyword">this</span>.LoadingComponent =</span><br><span class="line">        config.LoadingComponent || defaultLoadingComponent;</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        AsyncComponent: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">this</span>.load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.mounted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.mounted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load() &#123;</span><br><span class="line">      resolve().then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> AsyncComponent = m.default || m;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mounted) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; AsyncComponent &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.state.AsyncComponent = AsyncComponent; <span class="comment">// eslint-disable-line</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; AsyncComponent &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">const</span> &#123; LoadingComponent &#125; = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (AsyncComponent) <span class="keyword">return</span> &lt;AsyncComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line"></span><br><span class="line">      return &lt;LoadingComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数逻辑比较简洁，我们分析一下动态加载流程；</p><ul><li>在 constructor 里面调用 <code>this.load();</code> ( LoadingComponent 为占位 component)</li><li>在 <code>this.load();</code> 函数里面调用 <code>dynamic</code> 函数返回的 resolve 方法</li><li>resolve 方法实际上是一个 Promise，把相关 models 和 component 加载完之后 resolve (区分这两个 resolve)</li><li>加载完成之后返回 AsyncComponent (即加载的 Component)</li></ul><p>动态加载主流程结束，至于动态加载的代码分割工作，可以使用 webpack3 的 <code>import()</code> 动态加载能力(例子中也是这样使用的)。</p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>第五步骤就是 start 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.start(<span class="string">'#root'</span>);</span><br></pre></td></tr></table></figure><p>这个时候如果我们在 start 函数中传入 DomElement 或者 DomQueryString，就会直接启动应用了，如果我们这个时候不传入任何内容，实际上返回的是一个<code>&lt;Provider /&gt;</code> (React Component)，便于服务端渲染。 相关判断逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (container) &#123;</span><br><span class="line">     render(container, store, app, app._router);</span><br><span class="line">     app._plugin.apply(<span class="string">'onHmr'</span>)(render.bind(<span class="literal">null</span>, container, store, app));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> getProvider(store, <span class="keyword">this</span>, <span class="keyword">this</span>._router);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此，主要流程结束，以上几个步骤也包括了 dva 源码做的主要工作。</p><p>当然 dva 源码中还有一些比如前缀处理等工作，但是相比于以上内容非常简单，所以在这里不进行分析了。</p><h3 id="dva-core-文件目录"><a href="#dva-core-文件目录" class="headerlink" title="dva-core 文件目录"></a>dva-core 文件目录</h3><p>dva-core中的源码文件目录以及其功能:</p><ul><li>checkModel 对我们定义的 Model 进行检查是否符合要求</li><li>constants 非常简单的常量文件，目前只定义了一个常量：NAMESPACE_SEP(/)</li><li>cratePromiseMiddleware 笔者自己定义的 redux 插件</li><li>createStore 封装了 redux 原生的 createStore</li><li>getReducer 这里面的函数其实主要就是调用了 handleActions 文件导出的函数</li><li>getSaga 将用户输入的 effects 部分的键值对函数进行管理</li><li>handleActions 是将 dva 风格的 reducer 和 state 转化成 redux 本来接受的那种方式</li><li>index 主入口文件</li><li>Plugin 插件类：可以管理不同钩子事件的回调函数，拥有增加、获取、执行钩子函数的功能</li><li>perfixedDispatch 该文件提供了对 Dispatch 增加前缀的工具性函数 prefixedDispatch</li><li>prefixNamespace 该文件提供了对 reducer 和 effects 增加前缀的工具性函数 prefixNamespace</li><li>prefixType 判断是 reducer 还是 effects</li><li>subscriptions 该文件提供了运行 subscriptions 和调用用户返回的 unlisten 函数以及删除缓存的功能</li><li>utils 提供一些非常基础的工具函数</li></ul><h3 id="优势总结"><a href="#优势总结" class="headerlink" title="优势总结"></a>优势总结</h3><ul><li>动态 model，已经封装好了整套调用，动态添加/删除 model 变得非常简单</li><li>默认封装好了管理 effects 的方式，有限可选可配置，降低学习成本的同时代码更利于维护</li><li>易于上手，集成redux、redux-saga、react-router等常用功能</li></ul><h3 id="劣势总结"><a href="#劣势总结" class="headerlink" title="劣势总结"></a>劣势总结</h3><ul><li>版本区隔不明显，dva 有 1.x 和 2.x 两种版本，之间API有些差异，但是官网提供的一些样例等中没有说明基于的版本，并且有的还是基于旧版本的，会给新手带来很多疑惑。</li><li>内容繁杂，但是却没有一个整合性质的官方网站，大都是通过 list 的形式列下来写在README的。</li><li>目前比如动态加载等还存在着一些问题，和直接采用react配套工具写的效果有所区别。</li><li>很多 issues 不知道为什么就被关闭了，作者在最后也并未给出合理的解释。</li><li>dva2 之后有点将 effects 和 actions 混淆，这一点我也并不是非常认同，当然原作者可能有自己的考虑，这里不过多评议。</li></ul><p>总之，作为一个个人主力的项目(主要开发者贡献了99%以上的代码)，可以看出作者的功底深厚，经验丰富，但是由于这样一个体系化的东西牵扯内容较多，并且非常受制于react、redux、react-router、redux-saga等的版本影响，<strong>不建议具备一定规模的非阿里系团队在生产环境中使用</strong>，但是如果是快速成型的中小型项目或者个人应用，使用起来还是有很大帮助的。</p><h3 id="TODOS"><a href="#TODOS" class="headerlink" title="TODOS"></a>TODOS</h3><p>笔者也在准备做一个和 dva 处于同一性质，但是设计、实现和使用有所区别的框架，希望能够尽快落成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css学习</title>
      <link href="/2018/04/11/CSS%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/04/11/CSS%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标:"></a>课程目标:</h1><blockquote><ol><li>学会使用CSS选择器</li><li>熟记CSS样式和外观属性</li><li>熟练掌握CSS各种选择器</li><li>熟练掌握CSS各种选择器</li><li>熟练掌握CSS三种显示模式</li><li>熟练掌握CSS背景属性</li><li>熟练掌握CSS三大特性</li><li>熟练掌握CSS盒子模型</li><li>熟练掌握CSS浮动<br>10.熟练掌握CSS定位<br>11.熟练掌握CSS高级技巧强化CSS</li></ol></blockquote><h1 id="CSS的发展历程"><a href="#CSS的发展历程" class="headerlink" title="CSS的发展历程"></a>CSS的发展历程</h1><p>从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。<br>随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。</p><h1 id="CSS-网页的美容师"><a href="#CSS-网页的美容师" class="headerlink" title="CSS 网页的美容师"></a>CSS 网页的美容师</h1><p>CSS的出现，拯救了混乱的HTML，当让更加拯救了我们web开发者。 让我们的网页更加丰富多彩。   </p><p>CSS的最大贡献就是：  让 HTML 从样式中解脱苦海，  实现了 HTML 专注去做 结构呈现。 而样式交给 CSS 后，你完全可以放心的早点洗洗睡了！</p><p>而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师，不信，你看:</p><p><img src="img/baby.jpeg"></p><p>ps:  你跟Angelababy只差了一个妆容的距离</p><p>有人说， 没有不漂亮的女人，只有不会打扮的女人。</p><p>我想说， 没有不好看的网页，只有不会CSS的前端。</p><h1 id="CSS初识"><a href="#CSS初识" class="headerlink" title="CSS初识"></a>CSS初识</h1><p>CSS(Cascading Style Sheets)    美化样式</p><p>CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。</p><p>CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。</p><h1 id="引入CSS样式表（书写位置）"><a href="#引入CSS样式表（书写位置）" class="headerlink" title="引入CSS样式表（书写位置）"></a>引入CSS样式表（书写位置）</h1><p>CSS可以写到那个位置？ 是不是一定写到html文件里面呢？</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p><p>type=”text/CSS”  在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。</p><h2 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h2><p>内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。</p><h2 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h2><p>链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：  link 是个单标签哦!!!</p><p>该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span><br><span class="line">type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。</span><br><span class="line">rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span><br></pre></td></tr></table></figure><h2 id="三种样式表总结（位置）"><a href="#三种样式表总结（位置）" class="headerlink" title="三种样式表总结（位置）"></a>三种样式表总结（位置）</h2><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><h1 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h1><p>使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下：                                          </p><p><img src="img/gz.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在上面的样式规则中:</span><br><span class="line"></span><br><span class="line">1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。</span><br><span class="line">2.属性和属性值以“键值对”的形式出现。</span><br><span class="line">3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</span><br><span class="line">4.属性和属性值之间用英文“:”连接。</span><br><span class="line">5.多个“键值对”之间用英文“;”进行区分。</span><br><span class="line">可以用段落 和 表格的对齐的演示。</span><br></pre></td></tr></table></figure><h1 id="选择器（重点）"><a href="#选择器（重点）" class="headerlink" title="选择器（重点）"></a>选择器（重点）</h1><p>要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。</p><p><img src="img/ax.png"></p><p>如上图所以，要把里面的小黄人分为2组，最快的方法怎办？  </p><p>很多， 比如 一只眼睛的一组，剩下的一组  </p><p>选择器干啥的？   选择标签用的</p><p>这就用到基础选择器组：</p><h1 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h1><h2 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h2><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;  或者</span><br><span class="line">元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。</p><p>标签选择器 可以把某一类标签全部选择出来  div  span  </p><p>课堂案例：</p><p> 传智简介</p><h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签调用的时候用 class=“类名”  即可。</span><br></pre></td></tr></table></figure><p>类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 </p><p><img src="img/good.png">小技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.长名称或词组可以使用中横线来为选择器命名。</span><br><span class="line">2.不建议使用“_”下划线来命名CSS选择器。</span><br></pre></td></tr></table></figure><p>​    输入的时候少按一个shift键;<br>　浏览器兼容问题 (比如使用<em>tips的选择器命名，在IE6是无效的)<br>　能良好区分JavaScript变量命名(JS变量命名是用“</em>”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.不要纯数字、中文等命名， 尽量使用英文字母来表示。</span><br></pre></td></tr></table></figure><p>猜谜底游戏：</p><p><img src="img/midi.png" width="450">   你猜？</p><p>命名规范：  见附件（Web前端开发规范手册.doc）</p><p>命名是我们通俗约定的，但是没有规定必须用这些常用的命名。</p><p>课堂案例：</p><p> <img src="img/go.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        span &#123;</span></span><br><span class="line"><span class="undefined">        font-size: 100px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .blue &#123;</span></span><br><span class="line"><span class="undefined">        color: blue;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .red &#123;</span></span><br><span class="line"><span class="undefined">        color: red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .orange &#123;</span></span><br><span class="line"><span class="undefined">color: orange;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">.green &#123;</span></span><br><span class="line"><span class="undefined">color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span>G<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>o<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>o<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span>g<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"green"</span>&gt;</span>l<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>e<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h2><p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p><p><img src="img/lei.png"></p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。</span><br><span class="line">2. 各个类名中间用空格隔开。</span><br></pre></td></tr></table></figure><p>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pink fontWeight font20"</span>&gt;</span>亚瑟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font20"</span>&gt;</span>刘备<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14 pink"</span>&gt;</span>安其拉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14"</span>&gt;</span>貂蝉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类名选择器 ：&lt; div    class=“nav”&gt;      这个 div 的名字 就是 nav      nav 就是  div     这个 div 也是 nav  </p><p>&lt;  人    class  = 刘德华     &gt;      我们想要吧div  找到     div {}      .nav {}     </p><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p><p>用法基本和类选择器相同。</p><h2 id="id选择器和类选择器区别"><a href="#id选择器和类选择器区别" class="headerlink" title="id选择器和类选择器区别"></a>id选择器和类选择器区别</h2><p>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</p><p>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</p><p>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</p><p><strong><em>id选择器和类选择器最大的不同在于 使用次数上。</em></strong></p><p><img src="img/zfb.jpg"></p><h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>通配符   选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;                    <span class="comment">/* 定义外边距*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;                   <span class="comment">/* 定义内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>  这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 </p><h1 id="CSS字体样式属性"><a href="#CSS字体样式属性" class="headerlink" title="CSS字体样式属性"></a>CSS字体样式属性</h1><h2 id="font-size-字号大小"><a href="#font-size-字号大小" class="headerlink" title="font-size:字号大小"></a>font-size:字号大小</h2><p>font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下：</p><p><img src="img/dd.png"></p><h2 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family:字体"></a>font-family:字体</h2><p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码：</p><p>p{ font-family:”微软雅黑”;}</p><p>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。</p><blockquote><p><img src="img/good.png">常用技巧：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 现在网页中普遍使用14px+。</span><br><span class="line">2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。</span><br><span class="line">3. 各种字体之间必须使用英文状态下的逗号隔开。</span><br><span class="line">4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</span><br><span class="line">5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。</span><br><span class="line">6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</span><br></pre></td></tr></table></figure><h2 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h2><p>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。</p><p>方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。</p><p>方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。<br>font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。</p><p><img src="img/shs.png"></p><p>可以通过escape()  来测试属于什么字体。</p><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p><h2 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight:字体粗细"></a>font-weight:字体粗细</h2><p>字体加粗除了用 b  和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。</span><br></pre></td></tr></table></figure><p><img src="img/good.png">小技巧：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数字 400 等价于 <span class="selector-tag">normal</span>，而 700 等价于 <span class="selector-tag">bold</span>。  但是我们更喜欢用数字来表示。</span><br></pre></td></tr></table></figure><h2 id="font-style-字体风格"><a href="#font-style-字体风格" class="headerlink" title="font-style:字体风格"></a>font-style:字体风格</h2><p>字体倾斜除了用 i  和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。</p><p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><p>normal：默认值，浏览器会显示标准的字体样式。</p><p>italic：浏览器会显示斜体的字体样式。</p><p>oblique：浏览器会显示倾斜的字体样式。</p><p><img src="img/good.png">小技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。</span><br></pre></td></tr></table></figure><h2 id="font-综合设置字体样式-重点"><a href="#font-综合设置字体样式-重点" class="headerlink" title="font:综合设置字体样式 (重点)"></a>font:综合设置字体样式 (重点)</h2><p>font属性用于对字体样式进行综合设置，其基本语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。</span><br><span class="line"></span><br><span class="line">注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</span><br></pre></td></tr></table></figure><h1 id="CSS外观属性"><a href="#CSS外观属性" class="headerlink" title="CSS外观属性"></a>CSS外观属性</h1><h2 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color:文本颜色"></a>color:文本颜色</h2><p>color属性用于定义文本的颜色，其取值方式有如下3种：</p><p>1.预定义的颜色值，如red，green，blue等。</p><p>2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。</p><p>3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。</p><p>需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。</p><h2 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height:行间距"></a>line-height:行间距</h2><p>ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</p><p>一般情况下，行距比字号大7.8像素左右就可以了。</p><h2 id="text-align-水平对齐方式"><a href="#text-align-水平对齐方式" class="headerlink" title="text-align:水平对齐方式"></a>text-align:水平对齐方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下：</span><br></pre></td></tr></table></figure><p>left：左对齐（默认值）</p><p>right：右对齐</p><p>center：居中对齐</p><p>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</p><h2 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent:首行缩进"></a>text-indent:首行缩进</h2><p>text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。</p><p>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</p><h2 id="text-decoration-文本的装饰"><a href="#text-decoration-文本的装饰" class="headerlink" title="text-decoration 文本的装饰"></a>text-decoration 文本的装饰</h2><p>text-decoration   通常我们用于给链接修改装饰效果</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的</td></tr><tr><td>overline</td><td>定义文本上的一条线。</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h1 id="开发者工具（chrome）"><a href="#开发者工具（chrome）" class="headerlink" title="开发者工具（chrome）"></a>开发者工具（chrome）</h1><p>此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是：</p><p>“按F12”或者是 “shift+ctrl+i”   打开 开发者工具。</p><p>菜单：   右击网页空白出—查看 </p><p><img src="img/chrome.png"></p><p><img src="img/good.png">小技巧：</p><ol><li>ctrl+滚轮 可以 放大开发者工具代码大小。</li><li>左边是HTML元素结构   右边是CSS样式。</li><li>右边CSS样式可以改动数值和颜色查看更改后效果。</li></ol><h1 id="CSS复合选择器"><a href="#CSS复合选择器" class="headerlink" title="CSS复合选择器"></a>CSS复合选择器</h1><p>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。</p><h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><p>交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。</p><p><img src="img/jiao.png"></p><p><strong>记忆技巧：</strong></p><p>交集选择器 是 并且的意思。  即…又…的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：   p.one   选择的是： 类名为 .one  的 段落标签。</span><br></pre></td></tr></table></figure><p>用的相对来说比较少，不太建议使用。</p><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>并集选择器（CSS选择器分组）是各个选择器通过<strong style="color:#f00">逗号</strong>连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。</p><p><img src="img/bing.png"></p><p>记忆技巧：</p><p>并集选择器  和 的意思，  就是说，只要逗号隔开的，所有选择器都会执行后面样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如  .one, p , #test &#123;color: #F00;&#125;  表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。  通常用于集体声明。</span><br></pre></td></tr></table></figure><p><img src="img/hu.gif">  他和他，在一起， 在一起    一起的意思</p><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p><p><img src="img/hou.png"></p><p>子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 </p><p><img src="img/li.png"></p><h2 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h2><p>子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。</p><p><img src="img/zi1.png"></p><p>白话：  这里的子 指的是 亲儿子  不包含孙子 重孙子之类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：  .demo &gt; h3 &#123;color: red;&#125;   说明  h3 一定是demo 亲儿子。  demo 元素包含着h3。</span><br></pre></td></tr></table></figure><p><img src="img/san.jpg"></p><h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span>    <span class="comment">&lt;!-- 主导航栏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>公司首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>公司简介<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>公司产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>公司邮箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>公司电话<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sitenav"</span>&gt;</span>    <span class="comment">&lt;!-- 侧导航栏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-l"</span>&gt;</span>左侧侧导航栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-r"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在不修改以上代码的前提下，完成以下任务：</p><ol><li>链接 登录 的颜色为红色,同时主导航栏里面的所有的链接改为橙色     (简单)</li><li>主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。（中等)</li><li>主导航栏里面的一级菜单链接文字颜色为绿色。（难)</li></ol><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>  伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p><p> 伪娘    </p><p>类  .one  </p><p>伪类 :link</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了和我们刚才学的类选择器相区别，  类选择器是一个点 比如 <span class="selector-class">.demo</span> &#123;&#125;   而我们的伪类 用 2个点 就是 冒号  比如  <span class="selector-pseudo">:link</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><ul><li>:link      /<em> 未访问的链接 </em>/</li><li>:visited   /<em> 已访问的链接 </em>/</li><li>:hover     /<em> 鼠标移动到链接上 </em>/</li><li>:active    /<em> 选定的链接 </em>/</li></ul><p>   注意写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。   love   hate  爱上了讨厌 记忆法    或者   lv 包包 非常 hao </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;   <span class="comment">/* a是标签选择器  所有的链接 */</span></span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;   <span class="comment">/* :hover 是链接伪类选择器 鼠标经过 */</span></span><br><span class="line"><span class="attribute">color</span>: red; <span class="comment">/*  鼠标经过的时候，由原来的 灰色 变成了红色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS规则是使用     /*  需要注释的内容  */  进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。</span><br></pre></td></tr></table></figure><p>   例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;                 <span class="comment">/* 所有的字体是14像素大小*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sublime快捷方式"><a href="#sublime快捷方式" class="headerlink" title="sublime快捷方式"></a>sublime快捷方式</h1><p>sublime可以快速提高我们代码的书写方式</p><ol><li><p>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div></p></li><li><p>如果想要生成多个相同标签  加上 <em> 就可以了 比如   div</em>3  就可以快速生成3个div</p></li><li><p>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</p></li><li><p>如果有兄弟关系的标签，用  +  就可以了 比如 div+p  </p></li><li><p>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</p><p>​</p></li></ol><h1 id="标签显示模式（display）"><a href="#标签显示模式（display）" class="headerlink" title="标签显示模式（display）"></a>标签显示模式（display）</h1><p><img src="img/people.png"></p><p>非洲黑人：  皮肤内黑色素含量高，以吸收阳光中的紫外线，保护皮肤内部结构免遭损害，头发象羊毛一样卷曲，使每根卷发周围都有许多空隙，空隙充满空气，卷发有隔热作用。</p><p>欧洲白人： 生活寒带或着是说常年温度较低的地缘,加上年日照时间少，身体的黑色素沉淀比较少<code></code>所以出现皮肤、发色、瞳晕都呈现浅色</p><p>传智黄人：  我中间的。。。  <img src="img/h.jpg" alt=""></p><p>最重要的总结：  是为了更好的适应环境而完成的自然选择。 </p><p>同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p><p>标签的类型(显示模式)</p><p>HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下：</p><h2 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h2><p>每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 霸道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</span><br></pre></td></tr></table></figure><p>  <img src="img/xtf.jpg"></p><p>块级元素的特点：</p><p>（1）总是从新行开始</p><p>（2）高度，行高、外边距以及内边距都可以控制。</p><p>（3）宽度默认是容器的100%</p><p>（4）可以容纳内联元素和其他块元素。</p><h2 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h2><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。</span><br></pre></td></tr></table></figure><p>  <img src="img/wf.jpg">  我一样重要</p><p>行内元素的特点：</p><p>（1）和相邻行内元素在一行上。</p><p>（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</p><p>（3）默认宽度就是它本身内容的宽度。</p><p>（4）行内元素只能容纳文本或则其他行内元素。（a特殊 a里面可以放块级元素 ）</p><p>  <img src="img/w.jpg">    注意：</p><ol><li>只有 文字才 能组成段落  因此 p  里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li><li>链接里面不能再放链接。</li><li>a里面可以放块级元素</li></ol><h2 id="块级元素和行内元素区别"><a href="#块级元素和行内元素区别" class="headerlink" title="块级元素和行内元素区别"></a>块级元素和行内元素区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">块级元素的特点：</span><br><span class="line">（1）总是从新行开始</span><br><span class="line">（2）高度，行高、外边距以及内边距都可以控制。</span><br><span class="line">（3）宽度默认是容器的100%</span><br><span class="line">（4）可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行内元素的特点：</span><br><span class="line">（1）和相邻行内元素在一行上。</span><br><span class="line">（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</span><br><span class="line">（3）默认宽度就是它本身内容的宽度。</span><br><span class="line">（4）行内元素只能容纳文本或则其他行内元素。</span><br></pre></td></tr></table></figure><h2 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</span><br><span class="line"></span><br><span class="line">行内块元素的特点：</span><br><span class="line">（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。</span><br><span class="line">（2）默认宽度就是它本身内容的宽度。</span><br><span class="line">（3）高度，行高、外边距以及内边距都可以控制。</span><br></pre></td></tr></table></figure><p><img src="img/lyc.jpg" width="400"></p><h2 id="标签显示模式转换-display"><a href="#标签显示模式转换-display" class="headerlink" title="标签显示模式转换 display"></a>标签显示模式转换 display</h2><p>块转行内：display:inline;</p><p>行内转块：display:block;</p><p>块、行内元素转换为行内块： display: inline-block;</p><p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p><h2 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h2><p>1.写 三个 div  给定 100 * 100 的红色盒子     –  宽度 高度  背景色 </p><p>2.三个 span   也要求  150 * 150 绿色盒子 </p><ol start="3"><li>三个  a 链接   80 * 20  蓝色 盒子  要求 必须一行显示 这三个盒子</li><li>鼠标经过3个a链接的时候， 背景颜色变为  橙色     hover   bgc</li><li>导航栏案例</li></ol><h1 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h1><p>开始就形成良好的书写规范，是你专业化的开始。</p><h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><p>【强制】 选择器 与 { 之间必须包含空格。</p><p>示例： .selector { }</p><p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</p><p>示例：</p><p>font-size: 12px;</p><h2 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h2><p>【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.post,</span><br><span class="line">.page,</span><br><span class="line">.comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.post, .page, .comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* good */</span><br><span class="line">#username input &#123;&#125;</span><br><span class="line">.comment .avatar &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.page .header .login #username input &#123;&#125;</span><br><span class="line">.comment div * &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h2><p>【强制】 属性定义必须另起一行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.selector &#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure><p>【强制】 属性定义后必须以分号结尾。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="行高的测量"><a href="#行高的测量" class="headerlink" title="行高的测量"></a>行高的测量</h1><p><img src="img/line1.png"></p><p><img src="img/line2.png"></p><p>行高我们利用最多的一个地方是： 可以让一行文本在盒子中垂直居中对齐。</p><p>做法就是： 文字的行高等于盒子的高度。</p><p>这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。</p><p><img src="img/1.png"></p><p>上距离和下距离总是相等的，因此文字看上去是垂直居中的。</p><p>如果 行高 等 height 高度  文字会 垂直居中</p><p>如果行高 大于 高度   文字会 偏下 </p><p>如果行高小于高度   文字会  偏上 </p><h1 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h1><p>层叠 继承  优先级 是我们学习CSS 必须掌握的三个特性。</p><h2 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h2><p>所谓层叠性是指多种CSS样式的叠加。</p><p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p><p>比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。  就近原则</p><p>一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。</p><ol><li>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。</li><li>样式不冲突，不会层叠</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</span><br></pre></td></tr></table></figure><p><img src="img/hai.gif" width="600" height="400"></p><h2 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h2><p>所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。</p><p>简单的理解就是：  子承父业。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS最后的执行口诀：  龙生龙，凤生凤，老鼠生的孩子会打洞。</span><br></pre></td></tr></table></figure><p><img src="img/shu.gif"></p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）</span><br></pre></td></tr></table></figure><h2 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h2><p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。</p><p>在考虑权重时，初学者还需要注意一些特殊的情况，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。</span><br><span class="line"></span><br><span class="line">行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。</span><br><span class="line"></span><br><span class="line">权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。</span><br><span class="line"></span><br><span class="line">CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。</span><br></pre></td></tr></table></figure><h3 id="CSS特殊性（Specificity）"><a href="#CSS特殊性（Specificity）" class="headerlink" title="CSS特殊性（Specificity）"></a>CSS特殊性（Specificity）</h3><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：</p><p>specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 </p><table><thead><tr><th>继承或者* 的贡献值</th><th>0,0,0,0</th></tr></thead><tbody><tr><td>每个元素（标签）贡献值为</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类贡献值为</td><td>0,0,1,0</td></tr><tr><td>每个ID贡献值为</td><td>0,1,0,0</td></tr><tr><td>每个行内样式贡献值</td><td>1,0,0,0</td></tr><tr><td>每个!important贡献值  重要的</td><td>∞ 无穷大</td></tr></tbody></table><p>权重是可以叠加的</p><p> 比如的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div ul  li   ------&gt;      0,0,0,3</span><br><span class="line"></span><br><span class="line">.nav ul li   ------&gt;      0,0,1,2</span><br><span class="line"></span><br><span class="line">a:hover      -----—&gt;      0,0,1,1</span><br><span class="line"></span><br><span class="line">.nav a       ------&gt;      0,0,1,1   </span><br><span class="line"></span><br><span class="line">#nav p       -----&gt;       0,1,0,1</span><br></pre></td></tr></table></figure><p>​   </p><p>​      </p><p> <img src="img/w.jpg"> 注意：</p><p>1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p><ol><li>继承的 权重是 0  </li></ol><p>总结优先级：</p><ol><li>使用了 !important声明的规则。</li><li>内嵌在 HTML 元素的 style属性里面的声明。</li><li>使用了 ID 选择器的规则。</li><li>使用了类选择器、属性选择器、伪元素和伪类选择器的规则。</li><li>使用了元素选择器的规则。</li><li>只包含一个通用选择器的规则。</li><li>同一类选择器则遵循就近原则。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：权重是优先级的算法，层叠是优先级的表现</span><br></pre></td></tr></table></figure><h1 id="CSS-背景-background"><a href="#CSS-背景-background" class="headerlink" title="CSS 背景(background)"></a>CSS 背景(background)</h1><p>CSS 可以添加背景颜色和背景图片，以及来进行图片设置。</p><table><thead><tr><th>background-color</th><th>背景颜色</th></tr></thead><tbody><tr><td>background-image</td><td>背景图片地址</td></tr><tr><td>background-repeat</td><td>是否平铺</td></tr><tr><td>background-position</td><td>背景位置</td></tr><tr><td>background-attachment</td><td>背景固定还是滚动</td></tr><tr><td>背景的合写（复合属性）</td><td></td></tr><tr><td>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</td></tr></tbody></table><h2 id="背景图片-image"><a href="#背景图片-image" class="headerlink" title="背景图片(image)"></a>背景图片(image)</h2><p>语法： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image : none | url (url)</span><br></pre></td></tr></table></figure><p>参数： </p><p>none : 　无背景图（默认的）<br>url : 　使用绝对或相对地址指定背景图像 </p><p>background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。</p><p>小技巧：  我们提倡 背景图片后面的地址，url不要加引号。</p><h2 id="背景平铺（repeat）"><a href="#背景平铺（repeat）" class="headerlink" title="背景平铺（repeat）"></a>背景平铺（repeat）</h2><p>语法： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-repeat : repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure><p>参数： </p><p>repeat : 　背景图像在纵向和横向上平铺（默认的）</p><p>no-repeat : 　背景图像不平铺</p><p>repeat-x : 　背景图像在横向上平铺</p><p>repeat-y : 　背景图像在纵向平铺 </p><p>设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。</p><p>repeat-x : 　背景图像在横向上平铺  </p><p>repeat-y : 　背景图像在纵向平铺 </p><p><img src="img/y.png" width="600"></p><p>设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。</p><p><img src="img/q.png" width="600"></p><h2 id="背景位置-position"><a href="#背景位置-position" class="headerlink" title="背景位置(position)"></a>背景位置(position)</h2><p>语法： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-position : length || length</span><br><span class="line"></span><br><span class="line">background-position : position || position</span><br></pre></td></tr></table></figure><p>参数： </p><p>length : 　百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位<br>position : 　top | center | bottom | left | center | right </p><p>说明： </p><p>设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。<br>如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。</p><p>注意：</p><ol><li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li><li>如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top;   则 15px 一定是  x坐标   top是 y坐标。</li></ol><p>实际工作用的最多的，就是背景图片居中对齐了。</p><h2 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h2><p>语法： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-attachment : scroll | fixed</span><br></pre></td></tr></table></figure><p>参数： </p><p>scroll : 　背景图像是随对象内容滚动<br>fixed : 　背景图像固定 </p><p>说明： </p><p>设置或检索背景图像是随对象内容滚动还是固定的。</p><h2 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h2><p>background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</p><p>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">url</span>(<span class="selector-tag">image</span><span class="selector-class">.jpg</span>) <span class="selector-tag">repeat-y</span>  <span class="selector-tag">scroll</span> 50% 0 ;</span><br></pre></td></tr></table></figure><h2 id="背景透明-CSS3"><a href="#背景透明-CSS3" class="headerlink" title="背景透明(CSS3)"></a>背景透明(CSS3)</h2><p>CSS3支持背景半透明的写法语法格式是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br></pre></td></tr></table></figure><p> 最后一个参数是alpha 透明度  取值范围 0~1之间</p><p> 注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。</p><h2 id="导航栏案例"><a href="#导航栏案例" class="headerlink" title="导航栏案例"></a>导航栏案例</h2><p><strong>使用技巧</strong>：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">a &#123;</span></span><br><span class="line"><span class="undefined">width: 200px;</span></span><br><span class="line"><span class="undefined">height: 50px;</span></span><br><span class="line"><span class="css"><span class="comment">/* background-color: orange; */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;  <span class="comment">/* 把a 行内元素转换为行内块元素 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;  <span class="comment">/* 文字水平居中 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;  <span class="comment">/* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="undefined">font-size: 22px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;  <span class="comment">/* 取消下划线 文本装饰 */</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;  <span class="comment">/* 鼠标经过 给我们的链接添加背景图片*/</span></span></span><br><span class="line"><span class="undefined">background: url(images/h.png) no-repeat; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>专区说明<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>申请资格<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>兑换奖励<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>下载游戏<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="盒子模型（CSS重点）"><a href="#盒子模型（CSS重点）" class="headerlink" title="盒子模型（CSS重点）"></a>盒子模型（CSS重点）</h1><p>其实，CSS就三个大模块：  盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。  </p><p>所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。</p><h2 id="看透网页布局的本质"><a href="#看透网页布局的本质" class="headerlink" title="看透网页布局的本质"></a>看透网页布局的本质</h2><p>网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？</p><p><img src="img/t.png"></p><p>牛奶是怎样运输，让消费者购买的呢？</p><p><img src="img/m.jpg"></p><p>我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。</p><p>看透网页布局的本质：  把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。</p><p><img src="img/t1.png"></p><p>CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。</p><p><img src="img/j.jpg" width="300"></p><h2 id="盒子模型（Box-Model）"><a href="#盒子模型（Box-Model）" class="headerlink" title="盒子模型（Box Model）"></a>盒子模型（Box Model）</h2><p>这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 </p><p>首先，我们来看一张图，来体会下什么是盒子模型。</p><p><img src="img/box.png" width="700"></p><p>所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，<strong style="color: #f00;">每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。</strong></p><p><img src="img/boxs.png" width="700"></p><h2 id="盒子边框（border）"><a href="#盒子边框（border）" class="headerlink" title="盒子边框（border）"></a>盒子边框（border）</h2><p>边框就是那层皮。  橘子皮。。柚子皮。。橙子皮。。。</p><p>语法： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border : border-width || border-style || border-color</span><br></pre></td></tr></table></figure><p>边框属性—设置边框样式（border-style）</p><p>边框样式用于定义页面中边框的风格，常用属性值如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">none：没有边框即忽略所有边框的宽度（默认值）</span><br><span class="line"></span><br><span class="line">solid：边框为单实线(最为常用的)</span><br><span class="line"></span><br><span class="line">dashed：边框为虚线  </span><br><span class="line"></span><br><span class="line">dotted：边框为点线</span><br><span class="line"></span><br><span class="line">double：边框为双实线</span><br></pre></td></tr></table></figure><h3 id="盒子边框写法总结表"><a href="#盒子边框写法总结表" class="headerlink" title="盒子边框写法总结表"></a>盒子边框写法总结表</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>设置内容</td><td>样式属性</td><td>常用属性值</td></tr><tr><td>上边框</td><td>border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色;</td><td></td></tr><tr><td>下边框</td><td>border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色;</td><td></td></tr><tr><td>左边框</td><td>border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色;</td><td></td></tr><tr><td>右边框</td><td>border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色;</td><td></td></tr><tr><td>样式综合设置</td><td>border-style:上边 [右边 下边 左边];</td><td>none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线</td></tr><tr><td>宽度综合设置</td><td>border-width:上边 [右边 下边 左边];</td><td>像素值</td></tr><tr><td>颜色综合设置</td><td>border-color:上边 [右边 下边 左边];</td><td>颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)</td></tr><tr><td>边框综合设置</td><td>border:四边宽度 四边样式 四边颜色;</td></tr></tbody></table><pre><code>border-top: 1px solid red; /*上边框*/border-bottom: 2px solid green; /*下边框*/border-left: 1px solid blue;border-right: 5px solid pink;border: 1px solid red;</code></pre><h3 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h3><p>以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。</p><p>table{ border-collapse:collapse; }  collapse 单词是合并的意思</p><p>border-collapse:collapse; 表示相邻边框合并在一起。</p><h2 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h2><p>padding属性用于设置内边距。  是指 边框与内容之间的距离。</p><p>padding-top:上内边距</p><p>padding-right:右内边距</p><p>padding-bottom:下内边距</p><p>padding-left:左内边距</p><p> <img src="img/w.jpg">注意：  后面跟几个数值表示的意思是不一样的。</p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1个值</td><td>padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素</td></tr><tr><td>2个值</td><td>padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素</td></tr><tr><td>3个值</td><td>padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素</td></tr><tr><td>4个值</td><td>padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针</td></tr></tbody></table><p>课堂案例：  新浪导航</p><p><img src="img/al.gif"></p><h3 id="关于盒子宽度下列正确的是（）"><a href="#关于盒子宽度下列正确的是（）" class="headerlink" title="关于盒子宽度下列正确的是（）"></a>关于盒子宽度下列正确的是（）</h3><p>(A) 盒子宽：就是width的大小</p><p>(B) 盒子宽： padding-left + width + padding-right </p><p>(C) 盒子宽： border-left + width + border-right </p><p>(D) 盒子宽： border-left+ padding-left + width + padding-right + border-right</p><p>w 100  padding 10  border 5  ? 实际大小 ？   130 </p><h3 id="3关于盒子高度下列正确的是（）"><a href="#3关于盒子高度下列正确的是（）" class="headerlink" title="3关于盒子高度下列正确的是（）"></a>3关于盒子高度下列正确的是（）</h3><p>(A) 盒子高：就是height的大小</p><p>(B) 盒子高：padding-top +height + padding-bottom </p><p>(C) 盒子高：border-top + height + border-bottom</p><p>(D) 盒子高：border-top + padding-top +height + padding-bottom + border-bottom</p><p><strong>4**</strong> 关于根据下列代码计算 盒子宽高下列说法正确的是（）<strong>**</strong></p><p>div {</p><p>​            width: 200px;</p><p>​            height: 200px;</p><p>​            border: 1px solid #000000;</p><p>​            border-top: 5px solid blue;</p><p>​            padding: 50px;</p><p>​            padding-left: 100px;</p><p>​        }</p><p>(A) 宽度为200px 高度为200px</p><p>(B) 宽度为352px 高度为306px</p><p>(C) 宽度为302px 高度为307px</p><p>(D) 宽度为302px 高度为252px</p><h2 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h2><p>margin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。</p><p>margin-top:上外边距</p><p>margin-right:右外边距</p><p>margin-bottom:下外边距</p><p>margin-left:上外边距</p><p>margin:上外边距 右外边距  下外边距  左外边</p><p>取值顺序跟内边距相同。</p><h3 id="外边距实现盒子居中"><a href="#外边距实现盒子居中" class="headerlink" title="外边距实现盒子居中"></a>外边距实现盒子居中</h3><p>可以让一个盒子实现水平居中，需要满足一下两个条件：</p><ol><li>必须是块级元素。     </li><li>盒子必须指定了宽度（width）</li></ol><p>然后就给<strong>左右的外边距都设置为auto</strong>，就可使块级元素水平居中。</p><p>实际工作中常用这种方式进行网页布局，示例代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123; <span class="attribute">width</span>:<span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure><h3 id="文字盒子居中图片和背景区别"><a href="#文字盒子居中图片和背景区别" class="headerlink" title="文字盒子居中图片和背景区别"></a>文字盒子居中图片和背景区别</h3><ol><li>文字水平居中是  text-align: center</li><li>盒子水平居中  左右margin 改为 auto </li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>; <span class="comment">/*  文字居中水平 */</span></span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;  <span class="comment">/* 盒子水平居中  左右margin 改为 auto 就阔以了 */</span></span><br></pre></td></tr></table></figure><ol start="3"><li>插入图片 我们用的最多 比如产品展示类</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">img</span> &#123;  </span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;<span class="comment">/* 插入图片更改大小 width 和 height */</span></span><br><span class="line"><span class="attribute">height</span>: <span class="number">210px</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">30px</span>;  <span class="comment">/* 插入图片更改位置 可以用margin 或padding  盒模型 */</span></span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">50px</span>; <span class="comment">/* 插入当图片也是一个盒子 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid purple;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span> <span class="built_in">url</span>(images/sun.jpg) no-repeat;</span><br><span class="line"></span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">200px</span> <span class="number">210px</span>; <span class="comment">/*  背景图片更改大小只能用 background-size */</span></span><br><span class="line"><span class="attribute">background-position</span>: <span class="number">30px</span> <span class="number">50px</span>; <span class="comment">/* 背景图片更该位置 我用 background-position */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h3><p>为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">0</span>;         <span class="comment">/* 清除内边距 */</span></span><br><span class="line">   <span class="attribute">margin</span>:<span class="number">0</span>;          <span class="comment">/* 清除外边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：  行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。</p><p>我们尽量不要给行内元素指定上下的内外边距就好了。</p><h2 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h2><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p><h3 id="相邻块元素垂直外边距的合并"><a href="#相邻块元素垂直外边距的合并" class="headerlink" title="相邻块元素垂直外边距的合并"></a>相邻块元素垂直外边距的合并</h3><p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</p><p><img src="img/www.png"></p><p>解决方案：  避免就好了。</p><h3 id="嵌套块元素垂直外边距的合并"><a href="#嵌套块元素垂直外边距的合并" class="headerlink" title="嵌套块元素垂直外边距的合并"></a>嵌套块元素垂直外边距的合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p><p><img src="img/n.png"></p><p>解决方案：</p><ol><li>可以为父元素定义1像素的上边框或上内边距。</li><li>可以为父元素添加overflow:hidden。</li></ol><p>待续。。。。</p><h2 id="content宽度和高度"><a href="#content宽度和高度" class="headerlink" title="content宽度和高度"></a>content宽度和高度</h2><p>使用宽度属性width和高度属性height可以对盒子的大小进行控制。</p><p>width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。</p><p>大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*外盒尺寸计算（元素空间尺寸）*/</span><br><span class="line">Element空间高度 = content height + padding + border + margin</span><br><span class="line">Element 空间宽度 = content width + padding + border + margin</span><br><span class="line">/*内盒尺寸计算（元素实际大小）*/</span><br><span class="line">Element Height = content height + padding + border （Height为内容高度）</span><br><span class="line">Element Width = content width + padding + border （Width为内容宽度）</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。</p><p>2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。</p><p>3、<strong>如果一个盒子则会和父亲一样宽 占满父亲的宽度， 如果此盒子没有给定宽度 则padding 不会影响本盒子大小</strong>。</p><h2 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h2><p>开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？</p><p>答案是：  其实他们大部分情况下是可以混用的。  就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。</p><p>但是，总有一个最好用的吧，我们根据稳定性来分，建议如下：</p><p>按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width &gt;  padding  &gt;   margin</span><br></pre></td></tr></table></figure><p>原因：</p><ol><li><p>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</p></li><li><p>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</p></li><li><p>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</p><p>​</p></li></ol><h2 id="圆角边框-CSS3"><a href="#圆角边框-CSS3" class="headerlink" title="圆角边框(CSS3)"></a>圆角边框(CSS3)</h2><p>从此以后，我们的世界不只有矩形。radius 半径（距离）</p><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 50%;   让一个正方形  变成圆圈</span><br></pre></td></tr></table></figure><h2 id="盒子阴影-CSS3"><a href="#盒子阴影-CSS3" class="headerlink" title="盒子阴影(CSS3)"></a>盒子阴影(CSS3)</h2><p>语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；</span><br></pre></td></tr></table></figure><p><img src="img/1498467567011.png" alt="1498467567011"></p><ol><li>前两个属性是必须写的。其余的可以省略。</li><li>外阴影 (outset) 但是不能写    默认      想要内阴影  inset </li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="comment">/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */</span></span><br><span class="line"><span class="comment">/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */</span></span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">15px</span> <span class="number">30px</span>  <span class="built_in">rgba</span>(0, 0, 0, .4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动(float)"></a>浮动(float)</h1><h2 id="普通流-normal-flow"><a href="#普通流-normal-flow" class="headerlink" title="普通流(normal flow)"></a>普通流(normal flow)</h2><p>这个单词很多人翻译为 文档流 ， 字面翻译  普通流 或者标准流都可以。</p><p>前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？  </p><p>CSS的定位机制有3种：普通流（标准流）、浮动和定位。</p><p>html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。</p><p><img src="img/t.jpg"></p><h2 id="浮动-float-1"><a href="#浮动-float-1" class="headerlink" title="浮动(float)"></a>浮动(float)</h2><p>浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。</p><p><img src="img/l.png" style="width: 600px; border: 2px solid #000;"></p><p>后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释）</p><p><img src="img/d.png"></p><h2 id="什么是浮动？"><a href="#什么是浮动？" class="headerlink" title="什么是浮动？"></a>什么是浮动？</h2><p>元素的浮动是指设置了浮动属性的元素会脱离标准标准流的控制，移动到其父元素中指定位置的过程。</p><p>在CSS中，通过float属性来定义浮动，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;float:属性值;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr><tr><td>none</td><td>元素不浮动（默认值）</td></tr></tbody></table><h2 id="浮动详细内幕特性"><a href="#浮动详细内幕特性" class="headerlink" title="浮动详细内幕特性"></a>浮动详细内幕特性</h2><p>浮动脱离标准流，====脱标==== 不占位置，会影响标准流。浮动只有左右浮动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。</span><br></pre></td></tr></table></figure><p>   <img src="img/one.jpg" width="500"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。</span><br></pre></td></tr></table></figure><p>总结：  浮动 —&gt;    </p><p>浮动的目的就是为了让多个块级元素同一行上显示。  最核心的关键点就是   怎么排列的， 是否占有位置</p><p>float      浮 漏 特   </p><p>浮：    加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。<br>漏：    加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。<br>特：    特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。</p><h1 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h1><p>阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。</p><p>“版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。</p><h2 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h2><p>为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：</p><p>1、确定页面的版心（可视区）。</p><p>2、分析页面中的行模块，以及每个行模块中的列模块。</p><p>3、制作HTML结构 。</p><p>4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</p><h2 id="一列固定宽度且居中"><a href="#一列固定宽度且居中" class="headerlink" title="一列固定宽度且居中"></a>一列固定宽度且居中</h2><p><img src="img/yl.jpg" width="400"></p><p>最普通的，最为常用的结构</p><h2 id="两列左窄右宽型"><a href="#两列左窄右宽型" class="headerlink" title="两列左窄右宽型"></a>两列左窄右宽型</h2><p><img src="img/ll.jpg" width="400"></p><p>比如小米    <a href="http://www.mi.com" target="_blank"> 小米官网 </a></p><h2 id="通栏平均分布型"><a href="#通栏平均分布型" class="headerlink" title="通栏平均分布型"></a>通栏平均分布型</h2><p><img src="img/tl.jpg" width="600"></p><p>比如锤子    <a href="http://www.smartisan.com/" target="_blank"> 锤子官网 </a></p><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>人生就像乘坐北京地铁一号线：</p><p>途经国贸，羡慕繁华；</p><p>途经天安门，幻想权力；</p><p>途经金融街，梦想发财；</p><p>经过公主坟，遥想华丽家族；</p><p>经过玉泉路，依然雄心勃勃…</p><p>这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！</p><p>顿时醒悟：人生苦短，有始有终。 </p><p>好比我们的浮动，有浮动开始，则就应该有浮动结束。</p><h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><p>我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 <img src="img/wq.jpg" height="100">。</p><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。</p><p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><p>如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。</p><h2 id="清除浮动本质"><a href="#清除浮动本质" class="headerlink" title="清除浮动本质"></a>清除浮动本质</h2><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><p><img src="img/n.jpg"></p><p><img src="img/no.jpg"></p><p><img src="img/kc.jpg"></p><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><p>其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。</p><p>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;   clear 清除</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table><h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”clear:both”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>，或则其他标签br等亦可。</span><br></pre></td></tr></table></figure><p>优点： 通俗易懂，书写方便</p><p>缺点： 添加许多无意义的标签，结构化较差。  我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。</p><h3 id="父级添加overflow属性方法"><a href="#父级添加overflow属性方法" class="headerlink" title="父级添加overflow属性方法"></a>父级添加overflow属性方法</h3><p>可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。</span><br></pre></td></tr></table></figure><p>优点：  代码简洁</p><p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p><h3 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动"></a>使用after伪元素清除浮动</h3><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> </p><p>使用方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;  <span class="attribute">content</span>: <span class="string">""</span>; <span class="attribute">display</span>: block; <span class="attribute">height</span>: <span class="number">0</span>; <span class="attribute">clear</span>: both; <span class="attribute">visibility</span>: hidden;  &#125;   </span><br><span class="line"></span><br><span class="line">.clearfix &#123;*zoom: 1;&#125;   /* IE6、7 专有 */</span><br></pre></td></tr></table></figure><p>优点： 符合闭合浮动思想  结构语义化正确</p><p>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p><p>代表网站： 百度、淘宝网、网易等</p><p><img src="img/163.png" style="border: 1px dashed #3c3c3c;"></p><p>注意： content:””   尽量不带点</p><h3 id="使用before和after双伪元素清除浮动"><a href="#使用before和after双伪元素清除浮动" class="headerlink" title="使用before和after双伪元素清除浮动"></a>使用before和after双伪元素清除浮动</h3><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;  <span class="comment">/* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line"> <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：  代码更简洁</p><p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p><p>代表网站： 小米、腾讯等</p><h2 id="Photoshop基本使用"><a href="#Photoshop基本使用" class="headerlink" title="Photoshop基本使用"></a>Photoshop基本使用</h2><h2 id="PS界面组成："><a href="#PS界面组成：" class="headerlink" title="PS界面组成："></a>PS界面组成：</h2><p>ctrl + r  显示隐藏标尺      右击 标尺 — 把里面的单位一律改为像素</p><p>ctrl+ d  取消选区    </p><p>菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口<br>​    窗口菜单，可显示隐藏所有面板</p><p>工作区：（新建）</p><p>调整浮动面板</p><p><img src="img/jiemian.png"></p><h2 id="图层操作-重点"><a href="#图层操作-重点" class="headerlink" title="图层操作(重点)"></a>图层操作(重点)</h2><p> 图层面板快捷键   F7  其实图层就是一张张透明的纸  可以实现叠加问题。</p><p><img src="img/tuceng.png"></p><p> 图层选择： 使用移动工具V </p><p> 1、图层缩览图判断</p><p> 2、按住CTRL,在目标图像上单击</p><p> 3、将光标放置在目标图像上右键，选择图层名称</p><p>图层面板中加选图层：</p><p>1、按SHIFT，单击另一目标图层     中间所有图层被选中</p><p>2、按CTRL，单击另一目标图层     只选中目标图层</p><p>复制图层：选中目标图层后（移动工具状态下）</p><p>   1、按ALT拖拽图像</p><p>   2、CTRL+J      （重合）</p><p>案例： 摆放一个自行车</p><p><img src="img/bike.jpg"></p><h2 id="图层编组"><a href="#图层编组" class="headerlink" title="图层编组"></a>图层编组</h2><p>选中目标图层，CTRL+G   </p><p>取消编组：CTRL+SHIFT+G</p><p>双击图层名称可重新命名</p><p>双击组名称，可命名组</p><p>  移动工具V选择组或图层时，需设置选项栏</p><p><img src="img/1498465862231.png" alt="1498465862231"></p><h2 id="图层上下位置移动"><a href="#图层上下位置移动" class="headerlink" title="图层上下位置移动"></a>图层上下位置移动</h2><p>1、选中目标图层，在图层面拖拽</p><p>2、CTRL+]    向上移动图层<br>​       CTRL+[    向下移动图层</p><p>3、CTRL+SHIFT+]   图层置顶<br>​       CTRL+SHIFT+[   图层置底</p><p>移动选区或图像时：</p><p>移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。</p><p>ps中的撤销操作是：</p><p>ctrl+z  撤销一步</p><p>ctrl+alt+z  撤销多步</p><h2 id="Photoshop-切图"><a href="#Photoshop-切图" class="headerlink" title="Photoshop 切图"></a>Photoshop 切图</h2><p>PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图</p><h3 id="切片工具"><a href="#切片工具" class="headerlink" title="切片工具"></a>切片工具</h3><p><img src="img/1498466173246.png" alt="1498466173246"></p><ol><li><p>利用切片工具手动划出</p></li><li><p>图层菜单—新建基于图层的切片</p></li><li><p>利用标尺   基于参考线的切片 （选择切片工具）</p><p>​</p><p><img src="img/1498466734205.png" alt="1498466734205"></p></li><li><p>先选个一个整个的切片，  切片选择工具– 属性面板中有 “划分”   –可以等分数平分切图</p></li></ol><p>导出切片： 文件– 存储为web设备所用格式</p><h3 id="辅助线和切片使用及清除"><a href="#辅助线和切片使用及清除" class="headerlink" title="辅助线和切片使用及清除"></a>辅助线和切片使用及清除</h3><p>视图菜单– 清除 辅助线/ 清除切片</p><h3 id="切图插件"><a href="#切图插件" class="headerlink" title="切图插件"></a>切图插件</h3><p>Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。</p><p>官网: <a href="http://www.cutterman.cn/zh/cutterman" target="_blank" rel="noopener">http://www.cutterman.cn/zh/cutterman</a></p><p>注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。</p><p><img src="img/sample1.gif"></p><h1 id="项目案例：-云道页面"><a href="#项目案例：-云道页面" class="headerlink" title="项目案例： 云道页面"></a>项目案例： 云道页面</h1><p>案例练习目的是总结以前的css和html</p><p>还有ps的使用。</p><p>制作步骤：</p><ol><li>准备相关文件。（内部样式表) html文件(index.html)   图片文件</li><li>准备CSS 初始化。 书写结构和样式</li><li>确定版心（是1200像素)和各个模块。</li></ol><h1 id="定位-position"><a href="#定位-position" class="headerlink" title="定位(position)"></a>定位(position)</h1><p>background-position   背景定位</p><p>如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。</p><p>PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！</p><h2 id="为什么要用定位？"><a href="#为什么要用定位？" class="headerlink" title="为什么要用定位？"></a>为什么要用定位？</h2><p>那么定位，最长运用的场景再那里呢？   来看几幅图片，你一定会有感悟！</p><p>第一幅图， 小黄色块可以再图片上移动：</p><p><img src="img/1.gif" style="border: 1px dashed #3c3c3c;"></p><p>第二幅图， 左右箭头压住图片：</p><p><img src="img/2.gif" style="border: 1px dashed #3c3c3c;"></p><p>第三幅图,  hot 再盒子外面多出一块，更加突出：</p><p><img src="img/it.png" style="border: 1px dashed #3c3c3c;"></p><p>以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！</p><h2 id="元素的定位属性"><a href="#元素的定位属性" class="headerlink" title="元素的定位属性"></a>元素的定位属性</h2><p>元素的定位属性主要包括定位模式和边偏移两部分。</p><p>1、边偏移</p><table><thead><tr><th>边偏移属性</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>顶端偏移量，定义元素相对于其父元素上边线的距离</td></tr><tr><td>bottom</td><td>底部偏移量，定义元素相对于其父元素下边线的距离</td></tr><tr><td>left</td><td>左侧偏移量，定义元素相对于其父元素左边线的距离</td></tr><tr><td>right</td><td>右侧偏移量，定义元素相对于其父元素右边线的距离</td></tr></tbody></table><p>也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px;  left: 30px; 等等</p><p>2、定位模式(定位的分类)</p><p>在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：</p><p>选择器{position:属性值;}</p><p>position属性的常用值</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>static</td><td>自动定位（默认定位方式）</td></tr><tr><td>relative</td><td>相对定位，相对于其原文档流的位置进行定位</td></tr><tr><td>absolute</td><td>绝对定位，相对于其上一个已经定位的父元素进行定位</td></tr><tr><td>fixed</td><td>固定定位，相对于浏览器窗口进行定位</td></tr></tbody></table><h2 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位(static)"></a>静态定位(static)</h2><p>静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。</p><p>上面的话翻译成白话：  就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。</p><p>在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。</p><p>PS： 静态定位其实没啥可说的。</p><p>静态定位唯一的用处：  就是 取消定位。 position: static;</p><h2 id="相对定位relative-自恋型"><a href="#相对定位relative-自恋型" class="headerlink" title="相对定位relative(自恋型)"></a>相对定位relative(自恋型)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小笑话： </span><br><span class="line">刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。</span><br></pre></td></tr></table></figure><p><img src="img/smail.gif" width="100"></p><p>相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。</p><p>对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示：</p><p><img src="img/r.png"></p><p>注意：   </p><ol><li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。</li><li>其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li></ol><p>就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</p><p>如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。</p><h2 id="绝对定位absolute-拼爹型"><a href="#绝对定位absolute-拼爹型" class="headerlink" title="绝对定位absolute (拼爹型)"></a>绝对定位absolute (拼爹型)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小笑话：</span><br><span class="line"></span><br><span class="line">吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt;</span><br><span class="line"></span><br><span class="line">我一阵感动，刚想夸他两句。 </span><br><span class="line"></span><br><span class="line">儿子接着说：“以后全靠你让我拼爹了！”</span><br></pre></td></tr></table></figure><p><img src="img/smail.gif" width="100"></p><p>　[注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。</p><p>当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。</p><p>注意：    绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。</p><h3 id="父级没有定位"><a href="#父级没有定位" class="headerlink" title="父级没有定位"></a>父级没有定位</h3><p>若所有父元素都没有定位，以浏览器当前屏幕为准对齐(document文档)。</p><p><img src="img/ab.png"></p><h3 id="父级有定位"><a href="#父级有定位" class="headerlink" title="父级有定位"></a>父级有定位</h3><p>绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 </p><p><img src="img/ab1.png"></p><h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><p>这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。</p><p>这句话的意思是 子级是绝对定位的话， 父级要用相对定位。</p><p>首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。</p><p>就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。</p><p>但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图：</p><p><img src="img/zi.png" style="border: 1px dashed #3c3c3c;"></p><p>所以，我们可以得出如下结论：</p><p>因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。</p><p>父盒子布局时，需要占有位置，因此父亲只能是 相对定位. </p><p>这就是子绝父相的由来。</p><h2 id="绝对定位的盒子水平-垂直居中"><a href="#绝对定位的盒子水平-垂直居中" class="headerlink" title="绝对定位的盒子水平/垂直居中"></a>绝对定位的盒子水平/垂直居中</h2><p>普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了</p><p>定位的盒子也可以水平或者垂直居中，有一个算法。</p><ol><li><p>首先left 50%   父盒子的一半大小</p></li><li><p>然后走自己外边距负的一半值就可以了 margin-left。</p><p>​</p></li></ol><h2 id="固定定位fixed-认死理型"><a href="#固定定位fixed-认死理型" class="headerlink" title="固定定位fixed(认死理型)"></a>固定定位fixed(认死理型)</h2><p>固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。</p><p>当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。</p><p>固定定位有两点：</p><ol><li>固定定位的元素跟父亲没有任何关系，只认浏览器。</li><li>固定定位完全脱标，不占有位置，不随着滚动条滚动。</li></ol><p>记忆法：  就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。</p><p><img src="img/sun.jpg" width="100"></p><p>ie6等低版本浏览器不支持固定定位。</p><h2 id="叠放次序（z-index）"><a href="#叠放次序（z-index）" class="headerlink" title="叠放次序（z-index）"></a>叠放次序（z-index）</h2><p>当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。</p><p><img src="img/zzz.png"></p><p>在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。</p><p>比如：  z-index: 2;       font-weight: 700  </p><p>注意：</p><ol><li><p>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。</p></li><li><p>如果取值相同，则根据书写顺序，后来居上。</p></li><li><p>后面数字一定不能加单位。</p></li><li><p>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</p></li></ol><h1 id="四种定位总结"><a href="#四种定位总结" class="headerlink" title="四种定位总结"></a>四种定位总结</h1><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th>是否可以使用边偏移</th><th>移动位置基准</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td>不可以</td><td>正常模式</td></tr><tr><td>相对定位relative</td><td>脱标，占有位置</td><td>可以</td><td>相对自身位置移动（自恋型）</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于定位父级移动位置（拼爹型）</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于浏览器移动位置（认死理型）</td></tr></tbody></table><h1 id="定位模式转换"><a href="#定位模式转换" class="headerlink" title="定位模式转换"></a>定位模式转换</h1><p>跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， </p><p>行内块 的宽度和高度 跟内容有关系   </p><p><strong> 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。</strong></p><h1 id="CSS高级技巧"><a href="#CSS高级技巧" class="headerlink" title="CSS高级技巧"></a>CSS高级技巧</h1><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><p>在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。</p><p>他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！</p><h3 id="display-显示"><a href="#display-显示" class="headerlink" title="display 显示"></a>display 显示</h3><p>display 设置或检索对象是否及如何显示。</p><p>display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。</p><p>特点： 隐藏之后，不再保留位置。</p><h3 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h3><p>设置或检索是否显示对象。</p><p>visible : 　对象可视</p><p>hidden : 　对象隐藏</p><p>特点： 隐藏之后，继续保留原有位置。（停职留薪）</p><h3 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h3><p>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</p><p>visible : 　不剪切内容也不添加滚动条。</p><p>auto : 　 超出自动显示滚动条，不超出不显示滚动条</p><p>hidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉</p><p>scroll : 　不管超出内容否，总是显示滚动条</p><h2 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h2><p> 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽</p><h3 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h3><p> 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor :  default  小白 | pointer  小手  | move  移动  |  text  文本</span><br></pre></td></tr></table></figure><p> 鼠标放我身上查看效果哦：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:default"</span>&gt;</span>我是小白<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span>我是小手<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:move"</span>&gt;</span>我是移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:text"</span>&gt;</span>我是文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 尽量不要用hand  因为 火狐不支持     pointer ie6以上都支持的尽量用</p><h3 id="轮廓-outline"><a href="#轮廓-outline" class="headerlink" title="轮廓 outline"></a>轮廓 outline</h3><p> 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outline : outline-color ||outline-style || outline-width</span><br></pre></td></tr></table></figure><p> 但是我们都不关心可以设置多少，我们平时都是去掉的。</p><p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">style</span>=<span class="string">"outline: 0;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="防止拖拽文本域resize"><a href="#防止拖拽文本域resize" class="headerlink" title="防止拖拽文本域resize"></a>防止拖拽文本域resize</h3><p>resize：none    这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。</p><p>右下角可以拖拽： </p><textarea></textarea><p>右下角不可以拖拽： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">style</span>=<span class="string">"resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐"></a>vertical-align 垂直对齐</h2><p>以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto;</p><p>以前我们还讲过让文字居中对齐，是 text-align: center;</p><p>但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。</p><p>vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。</p><p><img src="img/xian.jpg"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertical-align : baseline |top |middle |bottom</span><br></pre></td></tr></table></figure><p>设置或检索对象内容的垂直对其方式。 </p><p>vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p><p><img src="img/1498467742995.png" alt="1498467742995"></p><h3 id="图片、表单和文字对齐"><a href="#图片、表单和文字对齐" class="headerlink" title="图片、表单和文字对齐"></a>图片、表单和文字对齐</h3><p>所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。</p><h3 id="去除图片底侧空白缝隙"><a href="#去除图片底侧空白缝隙" class="headerlink" title="去除图片底侧空白缝隙"></a>去除图片底侧空白缝隙</h3><p>有个很重要特性你要记住： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。</p><p><img src="img/3.jpg"></p><p>解决的方法就是：  </p><ol><li>给img vertical-align:middle | top等等。  让图片不要和基线对齐。<img src="img/1633.png" width="500" style="border: 1px dashed #ccc;"></li></ol><ol><li>给img 添加 display：block; 转换为块级元素就不会存在问题了。<img src="img/sina1.png" width="500" style="border: 1px dashed #ccc;"></li></ol><h1 id="溢出的文字隐藏"><a href="#溢出的文字隐藏" class="headerlink" title="溢出的文字隐藏"></a>溢出的文字隐藏</h1><h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 </p><p>normal : 　默认处理方式<br>nowrap : 　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</p><p>可以处理中文</p><h2 id="text-overflow-文字溢出"><a href="#text-overflow-文字溢出" class="headerlink" title="text-overflow 文字溢出"></a>text-overflow 文字溢出</h2><p>text-overflow : clip | ellipsis</p><p>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</p><p>clip : 　不显示省略标记（…），而是简单的裁切 </p><p>ellipsis : 　当对象内文本溢出时显示省略标记（…）</p><p>注意一定要首先强制一行内显示，再次和overflow属性  搭配使用</p><p>#CSS精灵技术（sprite） 小妖精  雪碧</p><h2 id="精灵技术产生的背景"><a href="#精灵技术产生的背景" class="headerlink" title="精灵技术产生的背景"></a>精灵技术产生的背景</h2><p><img src="img/sss.png"></p><p>图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</p><p>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p><h3 id="精灵技术本质"><a href="#精灵技术本质" class="headerlink" title="精灵技术本质"></a>精灵技术本质</h3><p>简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图（雪碧图），如下图所示为京东网站中的一个精灵图。</p><p><img src="img/jds.png" style="border: 1px dashed #ccc;"></p><h3 id="精灵技术的使用"><a href="#精灵技术的使用" class="headerlink" title="精灵技术的使用"></a>精灵技术的使用</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。</p><h3 id="制作精灵图"><a href="#制作精灵图" class="headerlink" title="制作精灵图"></a>制作精灵图</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p><p>大部分情况下，精灵图都是网页美工做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。</span><br><span class="line">我们精灵图的宽度取决于最宽的那个背景。 </span><br><span class="line">我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。</span><br><span class="line">在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。</span><br></pre></td></tr></table></figure><p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p><h1 id="滑动门"><a href="#滑动门" class="headerlink" title="滑动门"></a>滑动门</h1><p>先来体会下现实中的滑动门,或者你可以叫做推拉门：</p><p><img src="img/h.gif"></p><h2 id="滑动门出现的背景"><a href="#滑动门出现的背景" class="headerlink" title="滑动门出现的背景"></a>滑动门出现的背景</h2><p>制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？</p><p><img src="img/wxx.jpg"></p><p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。</p><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p>核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p><p>一般的经典布局都是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航栏内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结： </p><ol><li>a 设置 背景左侧，padding撑开合适宽度。    </li><li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li><li>之所以a包含span就是因为 整个导航都是可以点击的。</li></ol><h1 id="web字体"><a href="#web字体" class="headerlink" title="web字体"></a>web字体</h1><h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><p>不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。</p><p>1、TureType(.ttf)格式</p><p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；</p><p>2、OpenType(.otf)格式</p><p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；</p><p>3、Web Open Font Format(.woff)格式</p><p>woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；</p><p>4、Embedded Open Type(.eot)格式</p><p>.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；</p><p>5、SVG(.svg)格式</p><p>.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；</p><p>了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。</p><h1 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h1><p>图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont).</p><h2 id="字体图标优点"><a href="#字体图标优点" class="headerlink" title="字体图标优点"></a>字体图标优点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..</span><br><span class="line">但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...</span><br><span class="line">本身体积更小，但携带的信息并没有削减。</span><br><span class="line">几乎支持所有的浏览器</span><br><span class="line">移动端设备必备良药...</span><br></pre></td></tr></table></figure><h2 id="字体图标使用流程"><a href="#字体图标使用流程" class="headerlink" title="字体图标使用流程"></a>字体图标使用流程</h2><p>总体来说，字体图标按照如下流程：</p><p><img src="img/fontt.png"></p><h3 id="设计字体图标"><a href="#设计字体图标" class="headerlink" title="设计字体图标"></a>设计字体图标</h3><p>假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图：</p><p><img src="img/03.jpg"></p><p>  之后保存为svg格式，然后给我们前端人员就好了。 </p><p>  其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。</p><h3 id="上传生成字体包"><a href="#上传生成字体包" class="headerlink" title="上传生成字体包"></a>上传生成字体包</h3><p>   当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。</p><p>​    推荐网站： <a href="http://icomoon.io" target="_blank" rel="noopener">http://icomoon.io</a></p><p><strong>icomoon字库</strong></p><p>IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。</p><p>   推荐网站： <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p><p><strong>阿里icon font字库</strong></p><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p><p>这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！</p><p><strong>fontello</strong></p><p><a href="http://fontello.com/" target="_blank" rel="noopener">http://fontello.com/</a></p><p>在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。</p><p><strong>Font-Awesome</strong></p><p><a href="http://fortawesome.github.io/Font-Awesome/" target="_blank" rel="noopener">http://fortawesome.github.io/Font-Awesome/</a></p><p>这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。</p><p><strong>Glyphicon Halflings</strong></p><p><a href="http://glyphicons.com/" target="_blank" rel="noopener">http://glyphicons.com/</a></p><p>这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。</p><p><strong>Icons8</strong></p><p><a href="https://icons8.com/" target="_blank" rel="noopener">https://icons8.com/</a></p><p>提供PNG免费下载，像素大能到500PX</p><p><img src="img/1513132290173.png" alt="1513132290173"></p><h3 id="下载兼容字体包"><a href="#下载兼容字体包" class="headerlink" title="下载兼容字体包"></a>下载兼容字体包</h3><p>刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了</p><p>当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。</p><p><img src="img/fontt1.png"></p><p><img src="img/fontt2.png"></p><h3 id="字体引入到HTML"><a href="#字体引入到HTML" class="headerlink" title="字体引入到HTML"></a>字体引入到HTML</h3><p>得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。</p><ol><li><p>首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法</p><p><img src="img/1498032122244.png" alt="1498032122244"></p><h5 id="第一步：在样式里面声明字体：-告诉别人我们自己定义的字体"><a href="#第一步：在样式里面声明字体：-告诉别人我们自己定义的字体" class="headerlink" title="第一步：在样式里面声明字体： 告诉别人我们自己定义的字体"></a>第一步：在样式里面声明字体： 告诉别人我们自己定义的字体</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'icomoon'</span>;</span><br><span class="line">  <span class="attribute">src</span>:  <span class="built_in">url</span>(<span class="string">'fonts/icomoon.eot?7kkyc2'</span>);</span><br><span class="line">  <span class="attribute">src</span>:  <span class="built_in">url</span>(<span class="string">'fonts/icomoon.eot?7kkyc2#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.ttf?7kkyc2'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.woff?7kkyc2'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.svg?7kkyc2#icomoon'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二步：给盒子使用字体"><a href="#第二步：给盒子使用字体" class="headerlink" title="第二步：给盒子使用字体"></a>第二步：给盒子使用字体</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">"icomoon"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步：盒子里面添加结构"><a href="#第三步：盒子里面添加结构" class="headerlink" title="第三步：盒子里面添加结构"></a>第三步：盒子里面添加结构</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"> <span class="attribute">content</span>: <span class="string">"\e900"</span>;</span><br><span class="line">&#125;</span><br><span class="line">或者  </span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="追加新图标到原来库里面"><a href="#追加新图标到原来库里面" class="headerlink" title="追加新图标到原来库里面"></a>追加新图标到原来库里面</h3><p>如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做</p><p>把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。</p><p><img src="img/fontt5.png"></p></li></ol><p>## </p><h1 id="京东项目-一"><a href="#京东项目-一" class="headerlink" title="京东项目(一)"></a>京东项目(一)</h1><h2 id="京东项目介绍"><a href="#京东项目介绍" class="headerlink" title="京东项目介绍"></a>京东项目介绍</h2><p>项目名称：京东网<br>项目描述：京东首页公共部分的头部和尾部制作，京东首页中间部分。</p><p><img src="img/jd.png"></p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>现阶段电商类网站很流行，很多同学毕业之后会进入电商类企业工作，同时电商类网站需要的技术也是较为复杂的，这里用京东电商网站复习、总结、提高前面所学布局技术。其实，最主要的原因还是，为啥写京东？  因为刘强东，赚了我们的钱，抢了我们的女神， 我们也要学刘强东，赚别人的钱，抢别人..额，自己的女神。。。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>保证浏览器 ie7及以上, 火狐, 360, safari，chrome等。谁让我再测ie6，就跟谁急。。</li><li>熟悉CSS+DIV布局，页面的搭建工作</li><li>了解常用电商类网站的布局模式</li><li>为后期京东移动端做铺垫</li></ul><h2 id="几点思考"><a href="#几点思考" class="headerlink" title="几点思考"></a>几点思考</h2><p>(1). 开发工具  sublime  、fireworks（ps）、各种浏览器(ie6.7 要测看心情)</p><p>(2). CSS Reset 类库,为跨浏览器兼容做准备(也可以直接运用jd网站的初始化)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">normalize.css   只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。 你值得拥有。。 </span><br><span class="line"></span><br><span class="line">- 保护有用的浏览器默认样式而不是完全去掉它们</span><br><span class="line"></span><br><span class="line">- 一般化的样式：为大部分HTML元素提供</span><br><span class="line"></span><br><span class="line">- 修复浏览器自身的bug并保证各浏览器的一致性</span><br><span class="line"></span><br><span class="line">- 优化CSS可用性：用一些小技巧</span><br><span class="line"></span><br><span class="line">- 解释代码：用注释和详细的文档来</span><br></pre></td></tr></table></figure><p>(3). 技术栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML 结构 + CSS  布局 (因为我们就会这些。。。嘻嘻)</span><br></pre></td></tr></table></figure><p>(4). 低版本浏览器 单独制作一个跳转页面 (都是孩子，也舍不得打，舍不得扔)</p><p><a href="https://h5.m.jd.com/dev/3dm8aE4LDBNMkDfcCaRxLnVQ7rqo/index.html" target="_blank" rel="noopener">https://h5.m.jd.com/dev/3dm8aE4LDBNMkDfcCaRxLnVQ7rqo/index.html</a></p><p><img src="img/di.png" width="600"></p><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><p>要实现结构和样式相分离的设计思想。 根目录下有这4个文件（目录）。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>css</td><td>用于存放CSS文件</td></tr><tr><td>images</td><td>用于存放图片</td></tr><tr><td>index</td><td>京东首页 HTML</td></tr><tr><td>js</td><td>用于后期存放javascript文件</td></tr></tbody></table><h2 id="运用知识点"><a href="#运用知识点" class="headerlink" title="运用知识点"></a>运用知识点</h2><h3 id="引入ico图标"><a href="#引入ico图标" class="headerlink" title="引入ico图标"></a>引入ico图标</h3><p><img src="img/ico.png" style="border: 1px dashed #ccc; padding:3px;"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码：  &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;  type=&quot;image/x-icon&quot;/&gt;</span><br></pre></td></tr></table></figure><p>注意： </p><ol><li><p>她(它)不是iconfont字体哦 也不是图片。</p></li><li><p>位置是放到 head 标签中间。</p></li><li><p>后面的type=”image/x-icon”  属性可以省略。（我相信你也愿意省略。）</p></li><li><p>为了兼容性，请将favicon.ico 这个图标放到根目录下。（我们就不要任性了，听话放位置，省很多麻烦。。你好，我也好）</p><p>​</p></li></ol><h3 id="转换ico图标"><a href="#转换ico图标" class="headerlink" title="转换ico图标"></a>转换ico图标</h3><p>我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。 <a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a></p><h3 id="网站优化三大标签"><a href="#网站优化三大标签" class="headerlink" title="网站优化三大标签"></a>网站优化三大标签</h3><p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”！SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 简单的说就是，把产品做好，搜索引擎就会介绍客户来。  </p><p> 我们现在阶段主要进行站内优化。网站优化，我们应该要懂。。。</p><p><img src="img/san.png"></p><h4 id="网页title-标题"><a href="#网页title-标题" class="headerlink" title="网页title 标题"></a>网页title 标题</h4><p>title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。</p><p><img src="img/title.png" width="500"></p><p>建议：</p><p>首页标题：网站名（产品名）- 网站的介绍    </p><p>例如：</p><p>京东(JD.COM)-综合网购首选-正品低价、品质保障、配送及时、轻松购物！</p><p>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</p><h4 id="Description-网站说明"><a href="#Description-网站说明" class="headerlink" title="Description  网站说明"></a>Description  网站说明</h4><p>对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。<br>我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。</p><p>京东网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。</li><li>同样遵循简短原则，字符数含空格在内不要超过 120  个汉字。</li><li>补充在 title  和 keywords  中未能充分表述的说明.</li><li>用英文逗号 关键词1,关键词2</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="Keywords-关键字"><a href="#Keywords-关键字" class="headerlink" title="Keywords 关键字"></a>Keywords 关键字</h4><p>Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。</p><p>京东网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot; /&gt;</span><br></pre></td></tr></table></figure><p>小米网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="顶部（快捷菜单）所用知识点"><a href="#顶部（快捷菜单）所用知识点" class="headerlink" title="顶部（快捷菜单）所用知识点"></a>顶部（快捷菜单）所用知识点</h2><table><thead><tr><th>知识点</th><th>说明</th></tr></thead><tbody><tr><td>通栏的盒子</td><td>不用给宽度  默认为 100% &nbsp;但是加了浮动和定位的盒子需要 添加 100%</td></tr><tr><td>盒子居中对齐</td><td>margin: auto;  注意必须有宽度的块级元素，文字水平居中对齐是 text-align:center;</td></tr><tr><td>行高会继承</td><td>文字性质的，比如 颜色、文字大小、字体、行高等会继承父级元素</td></tr><tr><td>浮动元素、固定定位，绝对定位会模式转换</td><td>具有行内块特性，比如一行放多个，有高度和宽度，如果没有指定宽度，则会根据内容多少撑开。</td></tr></tbody></table><h2 id="logo-和搜索-header-区域所用知识点"><a href="#logo-和搜索-header-区域所用知识点" class="headerlink" title="logo 和搜索 header 区域所用知识点"></a>logo 和搜索 header 区域所用知识点</h2><h3 id="网页布局稳定性"><a href="#网页布局稳定性" class="headerlink" title="网页布局稳定性"></a>网页布局稳定性</h3><p><img src="img/x.png"></p><h3 id="宽度剩余法："><a href="#宽度剩余法：" class="headerlink" title="宽度剩余法："></a>宽度剩余法：</h3><p><img src="img/w.png"></p><table><thead><tr><th>知识点</th><th>说明</th></tr></thead><tbody><tr><td>浮动元素特性</td><td>1. 浮动可以让多个元素同一行显示 2. 浮动的元素是顶部对齐</td></tr><tr><td>logo优化</td><td>text-indent: -20000px; 隐藏文字， 背景图片</td></tr><tr><td>清除浮动</td><td>清除浮动的目的就是为了解决父亲高度为0的问题</td></tr><tr><td>鼠标样式</td><td>cursor: pointer;           小手      cursor: move;            四角箭头     cursor: text;  插入光标     cursor: default;  小白</td></tr><tr><td>不允许换行</td><td>white-space: nowrap;</td></tr></tbody></table><h2 id="nav导航栏所用知识点"><a href="#nav导航栏所用知识点" class="headerlink" title="nav导航栏所用知识点"></a>nav导航栏所用知识点</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>边框底侧</td><td>border-bottom: 2px solid #ccc;</td></tr><tr><td>定位重点</td><td>绝对定位不占位置  相对定位占有位置</td></tr><tr><td>标签语义化dl</td><td>dl也是块级元素 dt 是 定义标题  dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。</td></tr><tr><td>标题标签h</td><td>尽量少用h1，可以多用h2和h3等标签</td></tr></tbody></table><h2 id="页面底部所用知识点"><a href="#页面底部所用知识点" class="headerlink" title="页面底部所用知识点"></a>页面底部所用知识点</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>绝对定位的盒子居中对齐</td><td>盒子 left 50%  然后通过 margin 负值自己的宽度一半（固定定位也是如此）</td></tr></tbody></table><h3 id="固定定位的盒子靠近版心右侧对齐"><a href="#固定定位的盒子靠近版心右侧对齐" class="headerlink" title="固定定位的盒子靠近版心右侧对齐"></a>固定定位的盒子靠近版心右侧对齐</h3><p>跟绝对定位的盒子居中对齐原理差不多。</p><p>left 50%   然后 margin-left  版心宽度一半。</p><p><img src="img/guding.png" width="500"></p><p>学习目标:</p><ul><li><p>掌握京东中间部分制作</p></li><li><p>理解BFC使用</p></li><li><p>了解优雅降级和渐进增强</p></li><li><p>了解CSS压缩和验证工具</p><p>typora-copy-images-to: media</p></li></ul><hr><h1 id="京东项目-二"><a href="#京东项目-二" class="headerlink" title="京东项目(二)"></a>京东项目(二)</h1><h2 id="nav导航栏所用知识点-1"><a href="#nav导航栏所用知识点-1" class="headerlink" title="nav导航栏所用知识点"></a>nav导航栏所用知识点</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>边框底侧</td><td>border-bottom: 2px solid #ccc;</td></tr><tr><td>定位重点</td><td>绝对定位不占位置  相对定位占有位置</td></tr><tr><td>标签语义化dl</td><td>dl也是块级元素 dt 是 定义标题  dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。</td></tr><tr><td>标题标签h</td><td>尽量少用h1，可以多用h2和h3等标签</td></tr></tbody></table><h3 id="固定定位的盒子靠近版心右侧对齐-1"><a href="#固定定位的盒子靠近版心右侧对齐-1" class="headerlink" title="固定定位的盒子靠近版心右侧对齐"></a>固定定位的盒子靠近版心右侧对齐</h3><p>跟绝对定位的盒子居中对齐原理差不多。</p><p>left 50%   然后 margin-left  版心宽度一半。</p><p><img src="img/guding.png" width="500"></p><h2 id="焦点图部分所用知识点"><a href="#焦点图部分所用知识点" class="headerlink" title="焦点图部分所用知识点"></a>焦点图部分所用知识点</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>圆角矩形</td><td>border-radius: 左上角 右上角 右下角  左下角。</td></tr></tbody></table><p>负值自己的宽度一半（固定定位也是如此）</p><h2 id="背景半透明"><a href="#背景半透明" class="headerlink" title="背景半透明"></a>背景半透明</h2><p>1.强烈推荐：  background: rgba(r,g,b,alpha);</p><p>​     r,g,b 是红绿蓝的颜色，  alpha 是透明度的意思，取值范围是 0~1 之间。</p><p>2.了解ie低版本浏览器 半透明</p><p>filter:Alpha(opacity=50) ；   // opacity值为0 到 100</p><p>但是 此属性是盒子半透明，不是背景半透明哦，因为里面的内容也一起半透明了</p><p>因此，低版本的 ie6.7浏览器，我们不需要透明了，直接采用优雅降级的做法。</p><p>background: gary;</p><p>background: rgba(0,0,0,.2);</p><p>写上两句 背景， 低版本ie只执行gray， 其他浏览器执行 半透明下面这一句。</p><h2 id="CSS-W3C-统一验证工具"><a href="#CSS-W3C-统一验证工具" class="headerlink" title="CSS W3C 统一验证工具"></a>CSS W3C 统一验证工具</h2><p>CssStats 是一个在线的 CSS 代码分析工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网址是：  http://www.cssstats.com/</span><br></pre></td></tr></table></figure><p>如果你想要更全面的，这个神奇，你值得拥有：</p><p>W3C 统一验证工具：    <a href="http://validator.w3.org/unicorn/" target="_blank" rel="noopener">http://validator.w3.org/unicorn/</a>  ☆☆☆☆☆</p><p>因为它可以检测本地文件哦！！</p><p><a href="http://tool.chinaz.com/Tools/CssFormat.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/CssFormat.aspx</a>     css 代码压缩</p><h1 id="HTML5新标签与特性"><a href="#HTML5新标签与特性" class="headerlink" title="HTML5新标签与特性"></a>HTML5新标签与特性</h1><p>兼容性问题  （ie9 以上的版本） </p><p><img src="img/html.jpg"></p><h2 id="文档类型设定"><a href="#文档类型设定" class="headerlink" title="文档类型设定"></a>文档类型设定</h2><ul><li>document<ul><li>HTML:        sublime 输入  html:4s</li><li>XHTML:      sublime 输入  html:xt</li><li>HTML5        sublime 输入  html:5       &lt;!DOCTYPE html&gt;</li></ul></li></ul><h2 id="字符设定"><a href="#字符设定" class="headerlink" title="字符设定"></a>字符设定</h2><ul><li><meta http-equiv="charset" content="utf-8">：HTML与XHTML中建议这样去写</li><li><meta charset="utf-8">：HTML5的标签中建议这样去写</li></ul><h2 id="常用新标签"><a href="#常用新标签" class="headerlink" title="常用新标签"></a>常用新标签</h2><p> w3c  手册中文官网     :   <a href="http://w3school.com.cn/" target="_blank" rel="noopener">http://w3school.com.cn/</a></p><ul><li><p>header：定义文档的页眉 头部</p></li><li><p>nav：定义导航链接的部分</p></li><li><p>footer：定义文档或节的页脚 底部</p></li><li><p>article：定义文章。</p></li><li><p>section：定义文档中的节（section、区段）</p></li><li><p>aside：定义其所处内容之外的内容 侧边</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> 语义 :定义页面的头部  页眉<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>  语义 :定义导航栏 <span class="tag">&lt;/<span class="name">nav</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> 语义: 定义 页面底部 页脚<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> 语义:  定义文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> 语义： 定义区域<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> 语义： 定义其所处内容之外的内容 侧边<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>datalist   标签定义选项列表。请与 input 元素配合使用该元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"请输入明星"</span> <span class="attr">list</span>=<span class="string">"star"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"star"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"刘德华"</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"刘若英"</span>&gt;</span>刘若英<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"刘晓庆"</span>&gt;</span>刘晓庆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"戚薇"</span>&gt;</span>戚薇<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"戚继光"</span>&gt;</span>戚继光<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>fieldset 元素可将表单内的相关元素分组，打包      legend 搭配使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span>  标题</span><br><span class="line">    用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    密　码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h2 id="新增的input-type属性值："><a href="#新增的input-type属性值：" class="headerlink" title="新增的input type属性值："></a>新增的input type属性值：</h2><table><thead><tr><th><strong>类型<em>**</em></strong></th><th><strong>使用示例<em>**</em></strong></th><th><strong>含义<em>**</em></strong></th></tr></thead><tbody><tr><td><strong>email<em>**</em></strong></td><td><input type="email"></td><td>输入邮箱格式</td></tr><tr><td><strong>tel<em>**</em></strong></td><td><input type="tel"></td><td>输入手机号码格式</td></tr><tr><td><strong>url<em>**</em></strong></td><td><input type="url"></td><td>输入url格式</td></tr><tr><td><strong>number<em>**</em></strong></td><td><input type="number"></td><td>输入数字格式</td></tr><tr><td><strong>search<em>**</em></strong></td><td><input type="search"></td><td>搜索框（体现语义化）</td></tr><tr><td><strong>range<em>**</em></strong></td><td><input type="range"></td><td>自由拖动滑块</td></tr><tr><td><strong>time<em>**</em></strong></td><td><input type="time"></td><td>小时分钟</td></tr><tr><td><strong>date<em>**</em></strong></td><td><input type="date"></td><td>年月日</td></tr><tr><td><strong>datetime<em>**</em></strong></td><td><input type="datetime"></td><td>时间</td></tr><tr><td><strong>month<em>**</em></strong></td><td><input type="month"></td><td>月年</td></tr><tr><td><strong>week<em>**</em></strong></td><td><input type="week"></td><td>星期 年</td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="常用新属性"><a href="#常用新属性" class="headerlink" title="常用新属性"></a>常用新属性</h2><table><thead><tr><th><strong>属性<em>**</em></strong></th><th><strong>用法<em>**</em></strong></th><th><strong>含义<em>**</em></strong></th></tr></thead><tbody><tr><td><strong>placeholder<em>**</em></strong></td><td><input type="text" placeholder="请输入用户名"></td><td>占位符  当用户输入的时候 里面的文字消失  删除所有文字，自动返回</td></tr><tr><td><strong>autofocus<em>**</em></strong></td><td><input type="text" autofocus></td><td>规定当页面加载时 input 元素应该自动获得焦点</td></tr><tr><td><strong>multiple<em>**</em></strong></td><td><input type="file" multiple></td><td>多文件上传</td></tr><tr><td><strong>autocomplete<em>**</em></strong></td><td><input type="text" autocomplete="off"></td><td>规定表单是否应该启用自动完成功能  有2个值，一个是on 一个是off      on 代表记录已经输入的值  1.autocomplete 首先需要提交按钮 <br>2.这个表单您必须给他名字</td></tr><tr><td><strong>required<em>**</em></strong></td><td><input type="text" required></td><td>必填项  内容不能为空</td></tr><tr><td><strong>accesskey<em>**</em></strong></td><td><input type="text" accesskey="s"></td><td>规定激活（使元素获得焦点）元素的快捷键   采用 alt + s的形式</td></tr></tbody></table><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>学生档案<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"userName"</span>&gt;</span>姓名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">id</span>=<span class="string">"userName"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"userPhone"</span>&gt;</span>手机号码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">name</span>=<span class="string">"userPhone"</span> <span class="attr">id</span>=<span class="string">"userPhone"</span> <span class="attr">pattern</span>=<span class="string">"^1\d&#123;10&#125;$"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span>&gt;</span>邮箱地址:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">required</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"collage"</span>&gt;</span>所属学院:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"collage"</span> <span class="attr">id</span>=<span class="string">"collage"</span> <span class="attr">list</span>=<span class="string">"cList"</span> <span class="attr">placeholder</span>=<span class="string">"请选择"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cList"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"前端与移动开发学院"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"java学院"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"c++学院"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"score"</span>&gt;</span>入学成绩:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"score"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>学生档案思密达<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入学生名字"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>手机号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>所属学院:  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请选择学院"</span> <span class="attr">list</span>=<span class="string">"xueyuan"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"xueyuan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>java学院<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>前端学院<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>php学院<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>设计学院<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>出生日期:   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>成绩:  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>毕业时间:  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inTime"</span>&gt;</span>入学日期:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">id</span>=<span class="string">"inTime"</span> <span class="attr">name</span>=<span class="string">"inTime"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"leaveTime"</span>&gt;</span>毕业日期:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">id</span>=<span class="string">"leaveTime"</span> <span class="attr">name</span>=<span class="string">"leaveTime"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ul><li>embed：标签定义嵌入的内容</li><li>audio：播放音频</li><li>video：播放视频</li></ul><h3 id="多媒体-embed（会使用）"><a href="#多媒体-embed（会使用）" class="headerlink" title="多媒体 embed（会使用）"></a>多媒体 embed（会使用）</h3><p>embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。</p><p>因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf"</span> <span class="attr">allowFullScreen</span>=<span class="string">"true"</span> <span class="attr">quality</span>=<span class="string">"high"</span> <span class="attr">width</span>=<span class="string">"480"</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">align</span>=<span class="string">"middle"</span> <span class="attr">allowScriptAccess</span>=<span class="string">"always"</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><p> <img src="img/embed.png"></p><p> 优酷，土豆，爱奇艺，腾讯、乐视等等</p><ol><li>先上传   </li><li>在分享</li></ol><h3 id="多媒体-audio"><a href="#多媒体-audio" class="headerlink" title="多媒体 audio"></a>多媒体 audio</h3><p>HTML5通过<audio>标签来解决音频播放的问题。</audio></p><p>使用相当简单，如下图所示</p><p><img src="img/1498468026526.png" alt="1498468026526"></p><p>并且可以通过附加属性可以更友好控制音频的播放，如：</p><p>autoplay 自动播放</p><p>controls 是否显不默认播放控件</p><p>loop 循环播放    如果这个属性不写 默认播放一次        loop  或者  loop = “loop”    表示无限循环</p><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考</p><p><img src="img/1498468041058.png" alt="1498468041058"></p><p>多浏览器支持的方案，如下图</p><p><source> 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择</p><p><img src="img/1498468052965.png" alt="1498468052965"></p><h3 id="多媒体-video"><a href="#多媒体-video" class="headerlink" title="多媒体 video"></a>多媒体 video</h3><p>HTML5通过<audio>标签来解决音频播放的问题。</audio></p><p>同音频播放一样，<video>使用也相当简单，如下图</video></p><p><img src="img/1498468072194.png" alt="1498468072194"></p><p>同样，通过附加属性可以更友好的控制视频的播放</p><p>autoplay 自动播放</p><p>controls 是否显示默认播放控件</p><p>loop 循环播放</p><p>width 设置播放窗口宽度</p><p>height 设置播放窗口的高度</p><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考</p><p><img src="img/1498468086199.png" alt="1498468086199"></p><p><strong>多浏览器支持的方案，如下图<em>**</em></strong></p><p><img src="img/1498468097509.png" alt="1498468097509"></p><p># </p><h1 id="CSS3-新增选择器"><a href="#CSS3-新增选择器" class="headerlink" title="CSS3 新增选择器"></a>CSS3 新增选择器</h1><h2 id="结构-位置-伪类选择器（CSS3"><a href="#结构-位置-伪类选择器（CSS3" class="headerlink" title="结构(位置)伪类选择器（CSS3)"></a>结构(位置)伪类选择器（CSS3)</h2><ul><li>:first-child :选取属于其父元素的首个子元素的指定选择器</li><li>:last-child :选取属于其父元素的最后一个子元素的指定选择器</li><li>:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型</li><li>:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。<br>n 可以是数字、关键词或公式</li><li>​</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123; <span class="comment">/*  选择第一个孩子 */</span></span><br><span class="line">        <span class="attribute">color</span>: pink; </span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;   <span class="comment">/* 最后一个孩子 */</span></span><br><span class="line">        <span class="attribute">color</span>: purple;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4)</span> &#123;   <span class="comment">/* 选择第4个孩子  n  代表 第几个的意思 */</span> </span><br><span class="line"><span class="attribute">color</span>: skyblue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>选取标签带有某些特殊属性的选择器 我们成为属性选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取到 拥有 该属性的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class^=font]</span> &#123; <span class="comment">/*  class^=font 表示 font 开始位置就行了 */</span></span><br><span class="line"><span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class$=footer]</span> &#123; <span class="comment">/*  class$=footer 表示 footer 结束位置就行了 */</span></span><br><span class="line"><span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class*=tao]</span> &#123; <span class="comment">/* class*=tao  *=  表示tao 在任意位置都可以 */</span></span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font12"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font12"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"24font"</span>&gt;</span>属性选择器123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub-footer"</span>&gt;</span>属性选择器footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jd-footer"</span>&gt;</span>属性选择器footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-tao-nav"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-tao-header"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tao-header"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="伪元素选择器（CSS3"><a href="#伪元素选择器（CSS3" class="headerlink" title="伪元素选择器（CSS3)"></a>伪元素选择器（CSS3)</h2><ol><li>E::first-letter文本的第一个单词或字（如中文、日文、韩文等）</li><li>E::first-line 文本第一行；</li><li>E::selection 可改变选中文本的样式；</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: hotpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首行特殊样式 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">  <span class="comment">/* font-size: 50px; */</span></span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、E::before和E::after</p><p>在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::befor</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"开始"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"结束"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。</p><p>“:” 与 “::” 区别在于区分伪类和伪元素</p><p>之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查</p><p><strong>注意</strong></p><p>伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的<code>content</code>属性，表示伪元素的内容,设置:before和:after时必须设置其<code>content</code>属性，否则伪元素就不起作用。</p><h2 id="CSS3盒模型"><a href="#CSS3盒模型" class="headerlink" title="CSS3盒模型"></a>CSS3盒模型</h2><p>CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。</p><p>可以分成两种情况：</p><p>1、box-sizing: content-box  盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode</p><p>2、box-sizing: border-box  盒子大小为 width    就是说  padding 和 border 是包含到width里面的</p><p>注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: pink; </span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;  <span class="comment">/*  就是以前的标准盒模型  w3c */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">15px</span> solid red;</span><br><span class="line"><span class="comment">/* 盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;   <span class="comment">/* padding border  不撑开盒子 */</span></span><br><span class="line"><span class="attribute">border</span>: <span class="number">15px</span> solid red;</span><br><span class="line"><span class="comment">/* margin: 10px; */</span></span><br><span class="line"><span class="comment">/* 盒子大小为 width    就是说  padding 和 border 是包含到width里面的 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##学成在线综合案例 </p><h2 id="过渡-CSS3"><a href="#过渡-CSS3" class="headerlink" title="过渡(CSS3)"></a>过渡(CSS3)</h2><p>过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p><p>帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片</p><p><img src="img/1498445034712.png" alt="1498445034712"></p><p><img src="img/zhen.gif"></p><p>在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition: 要过渡的属性  花费时间  运动曲线  何时开始;</span><br><span class="line">如果有多组属性变化，还是用逗号隔开。</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th><th>CSS</th></tr></thead><tbody><tr><td>transition</td><td>简写属性，用于在一个属性中设置四个过渡属性。</td><td>3</td></tr><tr><td>transition-property</td><td>规定应用过渡的 CSS 属性的名称。</td><td>3</td></tr><tr><td>transition-duration</td><td>定义过渡效果花费的时间。默认是 0。</td><td>3</td></tr><tr><td>transition-timing-function</td><td>规定过渡效果的时间曲线。默认是 “ease”。</td><td>3</td></tr><tr><td>transition-delay</td><td>规定过渡效果何时开始。默认是 0。</td><td>3</td></tr></tbody></table><p>如果想要所有的属性都变化过渡， 写一个all 就可以</p><p>transition-duration  花费时间  单位是  秒     s    比如 0.5s    这个s单位必须写      ms 毫秒</p><p>运动曲线   默认是 ease</p><p> 何时开始  默认是 0s  立马开始</p><p>运动曲线示意图：</p><p><img src="img/1498445454760.png" alt="1498445454760"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line"><span class="comment">/* transition: 要过渡的属性  花费时间  运动曲线  何时开始; */</span></span><br><span class="line"><span class="attribute">transition</span>: width <span class="number">0.6s</span> ease <span class="number">0s</span>, height <span class="number">0.3s</span> ease-in <span class="number">1s</span>;</span><br><span class="line"><span class="comment">/* transtion 过渡的意思  这句话写到div里面而不是 hover里面 */</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;  <span class="comment">/* 鼠标经过盒子，我们的宽度变为400 */</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 0<span class="selector-class">.6s</span>;  <span class="comment">/* 所有属性都变化用all 就可以了  后面俩个属性可以省略 */</span></span><br></pre></td></tr></table></figure><h2 id="2D变形-CSS3-transform"><a href="#2D变形-CSS3-transform" class="headerlink" title="2D变形(CSS3) transform"></a>2D变形(CSS3) transform</h2><p>transform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。</p><p>变形转换 transform    transform  变换 变形的意思             《 transformers 变形金刚》</p><h3 id="移动-translate-x-y"><a href="#移动-translate-x-y" class="headerlink" title="移动 translate(x, y)"></a>移动 translate(x, y)</h3><p>translate 移动平移的意思</p><p><img src="img/1498443715586.png" alt="1498443715586"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translate</span>(50<span class="selector-tag">px</span>,50<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure><p>使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。</p><p>可以改变元素的位置，x、y可为负值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）</span><br><span class="line">translateX(x)仅水平方向移动（X轴移动）</span><br><span class="line">translateY(Y)仅垂直方向移动（Y轴移动）</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">499.9999px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">translate</span>(-50%,-50%);  <span class="comment">/* 走的自己的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 让定位的盒子水平居中</p><h3 id="缩放-scale-x-y"><a href="#缩放-scale-x-y" class="headerlink" title="缩放 scale(x, y)"></a>缩放 scale(x, y)</h3><p><img src="img/1498444645795.png" alt="1498444645795"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:scale(0.8</span>,1);</span><br></pre></td></tr></table></figure><p>可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）</span><br><span class="line">scaleX(x)元素仅水平方向缩放（X轴缩放）</span><br><span class="line">scaleY(y)元素仅垂直方向缩放（Y轴缩放）</span><br></pre></td></tr></table></figure><p> scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大</p><h3 id="旋转-rotate-deg"><a href="#旋转-rotate-deg" class="headerlink" title="旋转 rotate(deg)"></a>旋转 rotate(deg)</h3><p>可以对元素进行旋转，正值为顺时针，负值为逆时针；</p><p><img src="img/1498443651293.png" alt="1498443651293"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(45deg)</span>;</span><br></pre></td></tr></table></figure><p> 注意单位是 deg 度数      </p><h3 id="transform-origin可以调整元素转换变形的原点"><a href="#transform-origin可以调整元素转换变形的原点" class="headerlink" title="transform-origin可以调整元素转换变形的原点"></a>transform-origin可以调整元素转换变形的原点</h3><p><img src="img/1498443912530.png" alt="1498443912530"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">transform-origin</span>: left top;<span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg); &#125;  <span class="comment">/* 改变元素原点到左上角，然后进行顺时旋转45度 */</span></span><br></pre></td></tr></table></figure><p> 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用  px 像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">transform-origin</span>: <span class="number">10px</span> <span class="number">10px</span>;<span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg); &#125;  <span class="comment">/* 改变元素原点到x 为10  y 为10，然后进行顺时旋转45度 */</span></span><br></pre></td></tr></table></figure><p>案例旋转楚乔传</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">170px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">0.6s</span>;</span><br><span class="line"><span class="attribute">transform-origin</span>: top right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(1)</span> &#123;  <span class="comment">/* 鼠标经过div  第一张图片旋转 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(60deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(2)</span> &#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(120deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(3)</span> &#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(180deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(4)</span> &#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(240deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(5)</span> &#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(300deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span><span class="selector-pseudo">:nth-child(6)</span> &#123;  </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倾斜-skew-deg-deg"><a href="#倾斜-skew-deg-deg" class="headerlink" title="倾斜 skew(deg, deg)"></a>倾斜 skew(deg, deg)</h3><p><img src="img/1498443827389.png" alt="1498443827389"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:skew(30deg</span>,0<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><p>该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。</p><p>可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。</p><h2 id="3D变形-CSS3-transform"><a href="#3D变形-CSS3-transform" class="headerlink" title="3D变形(CSS3) transform"></a>3D变形(CSS3) transform</h2><p>2d    x  y  </p><p>3d  x  y  z</p><p> 左手坐标系</p><p>伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图</p><p><img src="img/1498445587576.png" alt="1498445587576"></p><p>CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图</p><p><img src="img/1498459001951.png" alt="1498459001951"></p><p>简单记住他们的坐标：</p><p> x左边是负的，右边是正的</p><p>y 上面是负的， 下面是正的</p><p>z 里面是负的， 外面是正的</p><h3 id="rotateX"><a href="#rotateX" class="headerlink" title="rotateX()"></a>rotateX()</h3><p> 就是沿着 x 立体旋转.</p><p><img src="img/1498445756802.png" alt="1498445756802"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>:all <span class="number">0.5s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hove</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotateX</span>(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY"><a href="#rotateY" class="headerlink" title="rotateY()"></a>rotateY()</h3><p>沿着y轴进行旋转</p><p><img src="img/1498446043198.png" alt="1498446043198"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>:all <span class="number">0.5s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hove</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotateX</span>(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateZ-"><a href="#rotateZ-" class="headerlink" title="rotateZ()"></a>rotateZ()</h3><p>沿着z轴进行旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>:all .<span class="number">25s</span> ease-in <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* transform:rotateX(180deg); */</span></span><br><span class="line">  <span class="comment">/* transform:rotateY(180deg); */</span></span><br><span class="line">  <span class="comment">/* transform:rotateZ(180deg); */</span></span><br><span class="line">  <span class="comment">/* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视(perspective)"></a>透视(perspective)</h3><p>电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。</p><p>透视可以将一个2D平面，在转换的过程当中，呈现3D效果。</p><ul><li>透视原理： 近大远小 。</li><li>浏览器透视：把近大远小的所有图像，透视在屏幕上。</li><li>perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置</li></ul><p>注：并非任何情况下需要透视效果，根据开发需要进行设置。</p><p>perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素</p><p>理解透视距离原理：</p><p><img src="img/1498446715314.png" alt="1498446715314"></p><h3 id="translateX-x"><a href="#translateX-x" class="headerlink" title="translateX(x)"></a>translateX(x)</h3><p>仅水平方向移动**（X轴移动）</p><p><img src="img/1498459697576.png" alt="1498459697576"></p><p>主要目的实现移动效果</p><h3 id="translateY-y"><a href="#translateY-y" class="headerlink" title="translateY(y)"></a>translateY(y)</h3><p>仅垂直方向移动（Y轴移动）</p><p><img src="img/1498459770252.png" alt="1498459770252"></p><h3 id="translateZ-z"><a href="#translateZ-z" class="headerlink" title="translateZ(z)"></a>translateZ(z)</h3><p>transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。</p><h3 id="translate3d-x-y-z"><a href="#translate3d-x-y-z" class="headerlink" title="translate3d(x,y,z)"></a>translate3d(x,y,z)</h3><p>[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值</p><h3 id="开门案例"><a href="#开门案例" class="headerlink" title="开门案例"></a>开门案例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.door</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">1000px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'images/dog.gif'</span>) no-repeat cover;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.door</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-10px);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid whitesmoke;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-10px);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid whitesmoke;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.door</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-130deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.door</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(130deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><p>backface-visibility 属性定义当元素不面向屏幕时是否可见。</p><h3 id="翻转盒子案例"><a href="#翻转盒子案例" class="headerlink" title="翻转盒子案例"></a>翻转盒子案例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">224px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">224px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">backface-visibility</span>: hidden; <span class="comment">/* 不是正面对象屏幕，就隐藏 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画-CSS3-animation"><a href="#动画-CSS3-animation" class="headerlink" title="动画(CSS3) animation"></a>动画(CSS3) animation</h2><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p><p>语法格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;</span><br></pre></td></tr></table></figure><p><img src="img/1498461096243.png" alt="1498461096243"></p><p>关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> 动画名称 &#123;</span><br><span class="line">  from&#123; 开始位置 &#125;  0%</span><br><span class="line">  to&#123;  结束  &#125;  100%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animation-iteration-count:infinite;  无限循环播放</span><br><span class="line">animation-play-state:paused;   暂停动画&quot;</span><br></pre></td></tr></table></figure><h3 id="小汽车案例"><a href="#小汽车案例" class="headerlink" title="小汽车案例"></a>小汽车案例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: goback;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> goback &#123;</span><br><span class="line">  0%&#123;&#125;</span><br><span class="line">  49%&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(1000px);</span><br><span class="line">  &#125;</span><br><span class="line">  55%&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(1000px) <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">  &#125;</span><br><span class="line">  95%&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(0) <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100%&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(0) <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伸缩布局-CSS3"><a href="#伸缩布局-CSS3" class="headerlink" title="伸缩布局(CSS3)"></a>伸缩布局(CSS3)</h2><p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p><p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向</p><p>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的</p><p>方向：默认主轴从左向右，侧轴默认从上到下</p><p>主轴和侧轴并不是固定不变的，通过flex-direction可以互换。</p><p><img src="img/1498441839910.png" alt="1498441839910"></p><p>Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多</p><p><strong>2、各属性详解<em>**</em></strong></p><p>1.flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配</p><p>min-width  最小值      min-width: 280px  最小宽度  不能小于 280</p><p>max-width: 1280px  最大宽度  不能大于 1280</p><p>2.flex-direction调整主轴方向（默认为水平方向）</p><p>flex-direction: column 垂直排列</p><p>flex-direction: row  水平排列</p><p><a href="http://m.ctrip.com/html5/" target="_blank" rel="noopener">http://m.ctrip.com/html5/</a>   携程网手机端地址</p><p>3、justify-content调整主轴对齐（水平对齐）</p><p>子盒子如何在父盒子里面水平对齐</p><table><thead><tr><th>值</th><th>描述</th><th>白话文</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值。项目位于容器的开头。</td><td>让子元素从父容器的开头开始排序但是盒子顺序不变</td></tr><tr><td>flex-end</td><td>项目位于容器的结尾。</td><td>让子元素从父容器的后面开始排序但是盒子顺序不变</td></tr><tr><td>center</td><td>项目位于容器的中心。</td><td>让子元素在父容器中间显示</td></tr><tr><td>space-between</td><td>项目位于各行之间留有空白的容器内。</td><td>左右的盒子贴近父盒子，中间的平均分布空白间距</td></tr><tr><td>space-around</td><td>项目位于各行之前、之间、之后都留有空白的容器内。</td><td>相当于给每个盒子添加了左右margin外边距</td></tr></tbody></table><p>4、align-items调整侧轴对齐（垂直对齐）</p><p>子盒子如何在父盒子里面垂直对齐（单行）</p><table><thead><tr><th>值</th><th>描述</th><th>白话文</th></tr></thead><tbody><tr><td>stretch</td><td>默认值。项目被拉伸以适应容器。</td><td>让子元素的高度拉伸适用父容器（子元素不给高度的前提下)</td></tr><tr><td>center</td><td>项目位于容器的中心。</td><td>垂直居中</td></tr><tr><td>flex-start</td><td>项目位于容器的开头。</td><td>垂直对齐开始位置 上对齐</td></tr><tr><td>flex-end</td><td>项目位于容器的结尾。</td><td>垂直对齐结束位置 底对齐</td></tr><tr><td></td><td></td></tr></tbody></table><p>5、flex-wrap控制是否换行</p><p>当我们子盒子内容宽度多于父盒子的时候如何处理</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>nowrap</td><td>默认值。规定灵活的项目不拆行或不拆列。  不换行，则 收缩（压缩） 显示  强制一行内显示</td></tr><tr><td>wrap</td><td>规定灵活的项目在必要的时候拆行或拆列。</td></tr><tr><td>wrap-reverse</td><td>规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><p>6、flex-flow是flex-direction、flex-wrap的简写形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">flex-direction</span>  <span class="selector-tag">flex-wrap</span>;</span><br></pre></td></tr></table></figure><p>白话记：    flex-flow: 排列方向   换不换行; </p><p>两个中间用空格</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="comment">/* flex-direction: row;</span></span><br><span class="line"><span class="comment">flex-wrap: wrap;   这两句话等价于下面的这句话*/</span></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">column</span> <span class="selector-tag">wrap</span>;  <span class="comment">/* 两者的综合 */</span></span><br></pre></td></tr></table></figure><p>7、align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐</p><p>align-content是针对flex容器里面多轴(多行)的情况,align-items是针对一行的情况进行排列。</p><p>必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。</p><table><thead><tr><th>值</th><th>描述</th><th>测试</th></tr></thead><tbody><tr><td>stretch</td><td>默认值。项目被拉伸以适应容器。</td><td></td></tr><tr><td>center</td><td>项目位于容器的中心。</td><td></td></tr><tr><td>flex-start</td><td>项目位于容器的开头。</td><td></td></tr><tr><td>flex-end</td><td>项目位于容器的结尾。</td><td></td></tr><tr><td>space-between</td><td>项目位于各行之间留有空白的容器内。</td><td></td></tr><tr><td>space-around</td><td>项目位于各行之前、之间、之后都留有空白的容器内。</td></tr></tbody></table><p>8、order控制子项目的排列顺序，正序方式排序，从小到大</p><p>用css 来控制盒子的前后顺序。  用order 就可以</p><p>用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: 1;</span><br></pre></td></tr></table></figure><p>此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值</p><h2 id="文字阴影-CSS3"><a href="#文字阴影-CSS3" class="headerlink" title="文字阴影(CSS3)"></a>文字阴影(CSS3)</h2><p>以后我们可以给我们的文字添加阴影效果了  Shadow  影子  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>:水平位置 垂直位置 模糊距离 阴影颜色;</span><br></pre></td></tr></table></figure><p><img src="img/1498467502625.png" alt="1498467502625"></p><ol><li>前两项是必须写的。  后两项可以选写。</li></ol><p><img src="img/1498467519665.png" alt="1498467519665"></p><h1 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC(块级格式化上下文)"></a>BFC(块级格式化上下文)</h1><p>BFC(Block formatting context)</p><p>直译为”块级格式化上下文”。</p><h3 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h3><p>我们前面讲过 元素的显示模式 display。 </p><p>分为 块级元素   行内元素  行内块元素 ，其实，它还有很多其他显示模式。</p><p><img src="img/dis.png" style="border: 1px dashed #ccc; padding: 5px;"></p><h3 id="那些元素会具有BFC的条件"><a href="#那些元素会具有BFC的条件" class="headerlink" title="那些元素会具有BFC的条件"></a>那些元素会具有BFC的条件</h3><p>不是所有的元素模式都能产生BFC，w3c 规范： </p><p>display 属性为 block, list-item, table 的元素，会产生BFC.</p><p>大家有么有发现这个三个都是用来布局最为合理的元素，因为他们就是用来可视化布局。</p><p>注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们暂且不研究。</p><p>这个BFC 有着具体的布局特性： </p><p><img src="img/box.gif"></p><p>有宽度和高度 ， 有 外边距margin  有内边距padding 有边框 border。</p><p>就好比，你有了练习武术的体格了。 有潜力，有资质。</p><p><img src="img/gu.jpeg" width="400"></p><h3 id="什么情况下可以让元素产生BFC"><a href="#什么情况下可以让元素产生BFC" class="headerlink" title="什么情况下可以让元素产生BFC"></a>什么情况下可以让元素产生BFC</h3><p>以上盒子具有BFC条件了，就是说有资质了，但是怎样触发才会产生BFC，从而创造这个封闭的环境呢？ </p><p>在好比，你光有资质还不行，你需要一定额外效果才能出发的武学潜力，要么你掉到悬崖下面，捡到了一本九阴真经，要么你学习葵花宝典，欲练此功必先….</p><p><img src="img/kuihua.png"><br>同样，要给这些元素添加如下属性就可以触发BFC。</p><p>-float属性不为none</p><p>-position为absolute或fixed</p><p>-display为inline-block, table-cell, table-caption, flex, inline-flex</p><p>-overflow不为visible。</p><h3 id="BFC元素所具有的特性"><a href="#BFC元素所具有的特性" class="headerlink" title="BFC元素所具有的特性"></a>BFC元素所具有的特性</h3><p>BFC布局规则特性：</p><p>1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.</p><p>2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p><p>3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p><ol><li>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</li><li>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</li></ol><p>它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p>白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。</p><p><img src="img/xiong.jpeg" width="400"></p><h3 id="BFC的主要用途"><a href="#BFC的主要用途" class="headerlink" title="BFC的主要用途"></a>BFC的主要用途</h3><p>BFC能用来做什么？</p><p>(1) 清除元素内部浮动</p><p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p><p>主要用到 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</span><br></pre></td></tr></table></figure><p><img src="img/fu.jpg"><br>(2) 解决外边距合并问题</p><p>外边距合并的问题。</p><p>主要用到 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</span><br></pre></td></tr></table></figure><p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p><p><img src="img/ma.png"></p><p>(3) 制作右侧自适应的盒子问题</p><p>主要用到 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</span><br></pre></td></tr></table></figure><p><img src="img/you.png"></p><h3 id="BFC-总结"><a href="#BFC-总结" class="headerlink" title="BFC 总结"></a>BFC 总结</h3><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。</p><h2 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h2><p>什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？</p><p>渐进增强 progressive enhancement：</p><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p> 类似 爬山，由低出往高处爬</p><p>  <img src="img/pa.png" width="400"></p><p>  <b>优雅降级 graceful degradation：</b></p><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p>类似蹦极，由高处往低处下落</p><p><img src="img/xia.jpg"></p><p>　　区别：渐进增强是向上兼容，优雅降级是向下兼容。</p><p>个人建议： 现在互联网发展很快， 连微软公司都抛弃了ie浏览器，转而支持 edge这样的高版本浏览器，我们很多情况下没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题。</p><h2 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h2><table><thead><tr><th>浏览器前缀</th><th>浏览器</th></tr></thead><tbody><tr><td>-webkit-</td><td>Google Chrome, Safari, Android Browser</td></tr><tr><td>-moz-</td><td>Firefox</td></tr><tr><td>-o-</td><td>Opera</td></tr><tr><td>-ms-</td><td>Internet Explorer, Edge</td></tr><tr><td>-khtml-</td><td>Konqueror</td></tr></tbody></table><p>后面我们会有 常用的解决H5和C3 的兼容解决文件， 我们这里暂且不涉及。</p><h2 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h2><p>在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴。如果你曾使用过制作图件，比如说Photoshop，你对线性渐变并不会陌生。</p><p>兼容性问题很严重，我们这里之讲解线性渐变</p><p>语法格式： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:-webkit-linear-gradient(</span>渐变的起始位置， 起始颜色， 结束颜色)；</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:-webkit-linear-gradient(</span>渐变的起始位置， 颜色 位置， 颜色位置....)；</span><br></pre></td></tr></table></figure><h2 id="背景缩放-CSS3"><a href="#背景缩放-CSS3" class="headerlink" title="背景缩放(CSS3)"></a>背景缩放(CSS3)</h2><p>通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。</p><p>其参数设置如下：</p><p>a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）</p><p>b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多</p><p>c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background-image: url('images/gyt.jpg');</span><br><span class="line"><span class="selector-tag">background-size</span>: 300<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="comment">/* background-size: contain; */</span></span><br><span class="line"><span class="comment">/* background-size: cover; */</span></span><br></pre></td></tr></table></figure><h2 id="多背景-CSS3"><a href="#多背景-CSS3" class="headerlink" title="多背景(CSS3)"></a>多背景(CSS3)</h2><p>以逗号分隔可以设置多背景，可用于自适应布局  做法就是 用逗号隔开就好了。</p><ul><li>一个元素可以设置多重背景图像。 </li><li>每组属性间使用逗号分隔。 </li><li>如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。</li><li>为了避免背景色将图像盖住，背景色通常都定义在最后一组上，</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px  ,</span><br><span class="line">   url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,</span><br><span class="line">   url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> css学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建利用Proxy和Reflect实现双向数据绑定的微框架</title>
      <link href="/2018/04/09/%E6%9E%84%E5%BB%BA%E5%88%A9%E7%94%A8Proxy%E5%92%8CReflect%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%BE%AE%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/04/09/%E6%9E%84%E5%BB%BA%E5%88%A9%E7%94%A8Proxy%E5%92%8CReflect%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%BE%AE%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p></blockquote><p>代码下载地址：<a href="https://github.com/aircloud/Polar.js" target="_blank" rel="noopener">这里下载</a></p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p><p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p><p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p><p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href="https://www.10000h.top/images/data_img/gif1.gif" target="_blank" rel="noopener">这里的链接</a>]</p><p><img src="https://www.10000h.top/images/data_img/gif1.gif" alt=""></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p><p>我的思路是这样的：</p><ul><li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li><li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li><li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li></ul><p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;label&gt;name:&lt;/label&gt;</span><br><span class="line">        &lt;input p-model = &quot;name&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;div&gt;name:&#123;&#123;name&#125;&#125; age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;i&gt;note:&#123;&#123;note&#125;&#125;&lt;/i&gt;&lt;br/&gt;</span><br><span class="line">    &lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var myPolar = new Polar(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &quot;niexiaotao&quot;,</span><br><span class="line">            age:16,</span><br><span class="line">            note:&quot;Student of Zhejiang University&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            test:function(e,addNumber)&#123;</span><br><span class="line">                console.log(&quot;e:&quot;,e);</span><br><span class="line">                this.data.age+=Number(addNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p><p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> constructor(configs)&#123;</span><br><span class="line">        this.root = this.el = document.querySelector(configs.el);</span><br><span class="line">        this._data = configs.data;</span><br><span class="line">        this._data.__bindings = &#123;&#125;;</span><br><span class="line">        //创建代理对象</span><br><span class="line">        this.data = new Proxy(this._data, &#123;set&#125;);</span><br><span class="line">        this.methods = configs.methods;</span><br><span class="line"></span><br><span class="line">        this._compile(this.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p><p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p><p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p><p>假设我们这样<code>&lt;div&gt;name:&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p><p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSet.__bindings[key].forEach(function(item)&#123;</span><br><span class="line">       //do something to update...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class="line">    this.el=el;//元素本身dom节点</span><br><span class="line">    this.polar = polar;//对应的polar实例</span><br><span class="line">    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span><br><span class="line">    this.el[this.attr] = this.elementValue = elementValue;//初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的set可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">    var dataSet = receiver || target;</span><br><span class="line">    dataSet.__bindings[key].forEach(function(item)&#123;</span><br><span class="line">        item.el[item.attr] = item.elementValue = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可能还有一个问题：我们的<code></code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name: age:&lt;/div&gt;</code>？</p><p>关于这两个问题，前者的答案是我们将<code></code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p><p>所以我们在<code>_compile</code>函数首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var _this = this;</span><br><span class="line"></span><br><span class="line">        var nodes = root.children;</span><br><span class="line"></span><br><span class="line">        var bindDataTester = new RegExp(&quot;&#123;&#123;(.*?)&#125;&#125;&quot;,&quot;ig&quot;);</span><br><span class="line"></span><br><span class="line">        for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            var node=nodes[i];</span><br><span class="line"></span><br><span class="line">            //如果还有html字节点，则递归</span><br><span class="line">            if(node.children.length)&#123;</span><br><span class="line">                this._compile(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var matches = node.innerHTML.match(bindDataTester);</span><br><span class="line">            if(matches)&#123;</span><br><span class="line">                var newMatches = matches.map(function (item) &#123;</span><br><span class="line">                    return  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,&quot;$1&quot;)</span><br><span class="line">                &#125;);</span><br><span class="line">                var splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class="line">                node.innerHTML=null;</span><br><span class="line">                //更新DOM，处理同一个textnode里面多次绑定情况</span><br><span class="line">                if(splitTextNodes[0])&#123;</span><br><span class="line">                    node.append(document.createTextNode(splitTextNodes[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                for(let ii=0;ii&lt;newMatches.length;ii++)&#123;</span><br><span class="line">                    var el = document.createTextNode(&apos;&apos;);</span><br><span class="line">                    node.appendChild(el);</span><br><span class="line">                    if(splitTextNodes[ii+1])&#123;</span><br><span class="line">                        node.append(document.createTextNode(splitTextNodes[ii+1]));</span><br><span class="line">                    &#125;</span><br><span class="line">                //对数据和dom进行绑定</span><br><span class="line">                let returnCode = !this._data.__bindings[newMatches[ii]]?</span><br><span class="line">                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,&quot;nodeValue&quot;,this.data[newMatches[ii]])]</span><br><span class="line">                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,&quot;nodeValue&quot;,this.data[newMatches[ii]]))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p><p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(node.hasAttribute((&quot;p-model&quot;))</span><br><span class="line">                &amp;&amp; node.tagName.toLocaleUpperCase()==&quot;INPUT&quot; || node.tagName.toLocaleUpperCase()==&quot;TEXTAREA&quot;)&#123;</span><br><span class="line">                node.addEventListener(&quot;input&quot;, (function () &#123;</span><br><span class="line"></span><br><span class="line">                    var attributeValue = node.getAttribute(&quot;p-model&quot;);</span><br><span class="line"></span><br><span class="line">                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,&quot;value&quot;,_this.data[attributeValue])) ;</span><br><span class="line">                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,&quot;value&quot;,_this.data[attributeValue])];</span><br><span class="line"></span><br><span class="line">                    return function (event) &#123;</span><br><span class="line">                        _this.data[attributeValue]=event.target.value</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p><p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p><p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(node.hasAttribute(&quot;p-click&quot;)) &#123;</span><br><span class="line">                node.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">                    var attributeValue=node.getAttribute(&quot;p-click&quot;);</span><br><span class="line">                    var args=/\(.*\)/.exec(attributeValue);</span><br><span class="line">                    //允许参数</span><br><span class="line">                    if(args) &#123;</span><br><span class="line">                        args=args[0];</span><br><span class="line">                        attributeValue=attributeValue.replace(args,&quot;&quot;);</span><br><span class="line">                        args=args.replace(/[\(\)\&apos;\&quot;]/g,&apos;&apos;).split(&quot;,&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else args=[];</span><br><span class="line">                    return function (event) &#123;</span><br><span class="line">                        _this.methods[attributeValue].apply(_this,[event,...args]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href="https://github.com/aircloud/Polar.js" target="_blank" rel="noopener">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p><p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p><hr><p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[PWA实践]serviceWorker生命周期、请求代理与通信</title>
      <link href="/2018/02/11/PWA%E5%AE%9E%E8%B7%B5-serviceWorker%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%90%86%E4%B8%8E%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/02/11/PWA%E5%AE%9E%E8%B7%B5-serviceWorker%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%90%86%E4%B8%8E%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者</p><p><strong>以下所有分析基于 Chrome V63</strong></p><h3 id="serviceWorker的挂载"><a href="#serviceWorker的挂载" class="headerlink" title="serviceWorker的挂载"></a>serviceWorker的挂载</h3><p>先来一段代码感受serviceWorker注册:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">      window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">          navigator.serviceWorker.register(&apos;/sw.js&apos;, &#123;scope: &apos;/&apos;&#125;)</span><br><span class="line">              .then(function (registration) &#123;</span><br><span class="line">                  // 注册成功</span><br><span class="line">                  console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch(function (err) &#123;</span><br><span class="line">                  // 注册失败:(</span><br><span class="line">                  console.log(&apos;ServiceWorker registration failed: &apos;, err);</span><br><span class="line">              &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们定义在<code>/sw.js</code>里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)</p><p>如果我们在<code>sw.js</code>没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker</p><h3 id="serviceWorker更新"><a href="#serviceWorker更新" class="headerlink" title="serviceWorker更新"></a>serviceWorker更新</h3><p>我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：</p><ul><li>仅变更文件名(比如把<code>sw.js</code>变成<code>sw-v2.js</code>或者加一个hash)</li><li>仅变更文件内容(仅仅更新<code>sw.js</code>的内容，文件名不变)</li><li>同时变更：同时执行以上两条</li></ul><p>在这里，我可以很负责的告诉你，<strong>变更serviceWorker文件名绝对不是一个好的实践</strong>，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。</p><p>所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:</p><p>(<em>下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面</em>，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)</p><ul><li><p>这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。</p></li><li><p>如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成<code>waiting to activate</code>状态</p></li></ul><p>也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。</p><p>当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了<code>self.skipWaiting();</code>，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    self.skipWaiting();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候，要分为以下两种情况：</p><ul><li>如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。</li><li>如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)</li></ul><p>Chrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。</p><h4 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h4><p>虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(&quot;/sw.js&quot;).then(reg =&gt; &#123;</span><br><span class="line">  reg.update();</span><br><span class="line">  // 或者 一段时间之后更新</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。</p><h4 id="install-生命周期钩子"><a href="#install-生命周期钩子" class="headerlink" title="install 生命周期钩子"></a>install 生命周期钩子</h4><p>我们一般会在 sw.js 中，添加<code>install</code>的回调，一般在回调中，我们会进行缓存处理操作，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;[sw2] serviceWorker Installed successfully&apos;, event)</span><br><span class="line"></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&apos;mysite-static-v1&apos;).then(function(cache) &#123;</span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &apos;/stylesheets/style.css&apos;,</span><br><span class="line">                &apos;/javascripts/common.39c462651d449a73b5bb.js&apos;,</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发<code>install</code>，如果之前没有， 那么在 serviceWorker 装载后会触发 <code>install</code>。</p><p>如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 <code>waiting to activate</code>，不会触发<code>install</code>，如果有变化，会触发<code>install</code>，但不会接管页面(上文中提到)。</p><h4 id="activate-生命周期钩子"><a href="#activate-生命周期钩子" class="headerlink" title="activate 生命周期钩子"></a>activate 生命周期钩子</h4><p>activate 在什么时候被触发呢？</p><p>如果当前页面没有 serviceworker ，那么会在 install 之后触发。</p><p>如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate</p><p>换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子</p><h3 id="serviceWorker-代理请求"><a href="#serviceWorker-代理请求" class="headerlink" title="serviceWorker 代理请求"></a>serviceWorker 代理请求</h3><p>serviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;[sw2] serviceWorker Installed successfully&apos;, event)</span><br><span class="line"></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&apos;mysite-static-v1&apos;).then(function(cache) &#123;</span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &apos;/stylesheets/style.css&apos;,</span><br><span class="line">                &apos;/javascripts/common.39c462651d449a73b5bb.js&apos;,</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;Handling fetch event for&apos;, event.request.url);</span><br><span class="line">    // console.log(&apos;[sw2]fetch but do nothing&apos;)</span><br><span class="line"></span><br><span class="line">    event.respondWith(</span><br><span class="line">        // caches.match() will look for a cache entry in all of the caches available to the service worker.</span><br><span class="line">        // It&apos;s an alternative to first opening a specific named cache and then matching on that.</span><br><span class="line">        caches.match(event.request).then(function(response) &#123;</span><br><span class="line">            if (response) &#123;</span><br><span class="line">                console.log(&apos;Found response in cache:&apos;, response);</span><br><span class="line"></span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            console.log(&apos;No response found in cache. About to fetch from network...&apos;);</span><br><span class="line"></span><br><span class="line">            // event.request will always have the proper mode set (&apos;cors, &apos;no-cors&apos;, etc.) so we don&apos;t</span><br><span class="line">            // have to hardcode &apos;no-cors&apos; like we do when fetch()ing in the install handler.</span><br><span class="line">            return fetch(event.request).then(function(response) &#123;</span><br><span class="line">                console.log(&apos;Response from network is:&apos;, response);</span><br><span class="line"></span><br><span class="line">                return response;</span><br><span class="line">            &#125;).catch(function(error) &#123;</span><br><span class="line">                // This catch() will handle exceptions thrown from the fetch() operation.</span><br><span class="line">                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.</span><br><span class="line">                // It will return a normal response object that has the appropriate error code set.</span><br><span class="line">                console.error(&apos;Fetching failed:&apos;, error);</span><br><span class="line"></span><br><span class="line">                throw error;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有两点要注意的：</p><p>我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：</p><p><img src="https://www.10000h.top/images/sw_1.png" alt=""></p><p>第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。</p><p>另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。</p><h3 id="serviceWorker-和-页面之间的通信"><a href="#serviceWorker-和-页面之间的通信" class="headerlink" title="serviceWorker 和 页面之间的通信"></a>serviceWorker 和 页面之间的通信</h3><p>serviceWorker向页面发消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sw.js:</span><br><span class="line"></span><br><span class="line">self.clients.matchAll().then(clients =&gt; &#123;</span><br><span class="line">    clients.forEach(client =&gt; &#123;</span><br><span class="line">        console.log(&apos;%c [sw message]&apos;, &apos;color:#00aa00&apos;, client)</span><br><span class="line">        client.postMessage(&quot;This message is from serviceWorker&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主页面:</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">    console.log(&apos;[Main] receive from serviceWorker:&apos;, event.data, event)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，这里面是有坑的：</p><ul><li>主界面的事件监听需要等serviceWorker注册完毕后，所以一般<code>navigator.serviceWorker.register</code>的回调到来之后再进行注册(或者延迟足够的时间)。</li><li>如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。</li></ul><p>从页面向 serviceWorker 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主页面:</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(&apos;hello serviceWorker&apos;);</span><br><span class="line"></span><br><span class="line">sw.js:</span><br><span class="line">self.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">    console.log(&quot;[sw from main]&quot;,event.data); // 输出：&apos;sw.updatedone&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。</p><p>也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。</p><p>记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。</p><p><strong>以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS安装node8.x版本</title>
      <link href="/2017/12/15/CentOS%E5%AE%89%E8%A3%85node8-x%E7%89%88%E6%9C%AC/"/>
      <url>/2017/12/15/CentOS%E5%AE%89%E8%A3%85node8-x%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="CentOS-安装-node-8-x-版本"><a href="#CentOS-安装-node-8-x-版本" class="headerlink" title="CentOS 安装 node 8.x 版本"></a>CentOS 安装 node 8.x 版本</h3><p>由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：</p><p>安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove nodejs npm -y</span><br></pre></td></tr></table></figure><p>首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>解压缩:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf node-v8.0.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>进入解压目录下的 bin 目录，执行 ls 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd node-v8.0.0-linux-x64/bin &amp;&amp; ls</span><br></pre></td></tr></table></figure><p>我们发现有node 和 npm</p><p>这个时候我们测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node -v</span><br></pre></td></tr></table></figure><p>这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。</p><p>这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/node</span><br><span class="line">sudo rm -rf /usr/bin/npm</span><br></pre></td></tr></table></figure><p>然后建立链接文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm</span><br></pre></td></tr></table></figure><p>注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。</p><p>然后我们可以通过<code>node -v</code>等测试已经安装成功。</p>]]></content>
      
      
      
        <tags>
            
            <tag> centOS </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入浏览器web渲染与优化-续</title>
      <link href="/2017/08/31/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96-%E7%BB%AD/"/>
      <url>/2017/08/31/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96-%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p></blockquote><p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p><p>首先，一个网页的加载，需要什么工作呢？</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P1.png" alt=""></p><p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p><p>数据到端之后，又经过以下过程，才最终显示出来：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P2.png" alt=""></p><p>在这个过程中，我们怎么衡量性能呢？</p><p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P3.png" alt=""></p><p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p><p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p><p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p><p>那么<strong>首屏时间</strong>怎么测量呢？</p><p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p><p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p><ul><li>资源阻塞内核线程</li></ul><p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p><p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p><p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p><ul><li>中文Layout的时间过长</li></ul><p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p><p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p><ul><li>首次渲染太慢</li></ul><p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p><ul><li>一次解析内容过多</li></ul><p>采用首屏探测机制，优先解析首屏内容。</p><p>另外，这里可以前端配合去做首屏优化：</p><p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=‘x5-pagetype’ content=‘optpage&apos;&gt;</span><br></pre></td></tr></table></figure><p>然后在首屏分界的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;first-screen/&gt;</span><br></pre></td></tr></table></figure><p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p><p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p><ul><li>预先操作</li></ul><p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p><ul><li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li><li>经常访问的站点可以预解析DNS</li><li>点击地址栏时进行搜索预连接</li><li>点击链接时，先预链接，再做跳转。</li><li>……</li></ul><h3 id="其他方式优化"><a href="#其他方式优化" class="headerlink" title="其他方式优化"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p><h5 id="后台提速"><a href="#后台提速" class="headerlink" title="后台提速"></a>后台提速</h5><ul><li>直接使用IP，节省dns的查询时间</li><li>维持长连接</li><li>HTTP1.1启用包头节省</li><li>服务器缓存</li><li>文本资源压缩传输GZIP(6)</li><li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li></ul><h5 id="降低网络时延"><a href="#降低网络时延" class="headerlink" title="降低网络时延"></a>降低网络时延</h5><ul><li>就快接入和就近接入</li></ul><p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p><p>相比较而言，选择就快接入，是一个能够提效的方式。</p><h5 id="内容防劫持"><a href="#内容防劫持" class="headerlink" title="内容防劫持"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p><h4 id="QUIC和http2"><a href="#QUIC和http2" class="headerlink" title="QUIC和http2"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p><ul><li>延迟少</li><li>前向纠错</li><li>没有<strong>线头阻塞[注1]</strong>的多路复用</li><li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li></ul><p>——————</p><p>注1：线头阻塞：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P4.png" alt=""></p><p>——————</p><p>附1: 带宽和延迟对网页加载的影响：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/X1.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入浏览器web渲染与优化</title>
      <link href="/2017/08/27/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2017/08/27/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p></blockquote><p>文章主要分为以下几个部分：</p><ul><li>blink内核的渲染机制</li><li>chrome内核架构变迁</li><li>分层渲染</li><li>动画 &amp; canvas &amp; WebGl</li></ul><p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p><h3 id="blink内核的渲染机制"><a href="#blink内核的渲染机制" class="headerlink" title="blink内核的渲染机制"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p><p>一个页面的显示，实际上主要经历了下面的四个流程：</p><p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p><p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p><p><img src="https://www.10000h.top/images/data_img/webRender/P6.PNG" alt=""></p><p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p><ul><li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li><li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li><li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li></ul><p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p><p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p><p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p><ul><li>硬件加速合成上屏</li><li>2D Canvas、Video的硬件加速</li><li>GPU光栅化<ul><li>GPU光栅化速度更快，内存和CPU的消耗更少</li><li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li><li>GPU光栅化是未来趋势</li></ul></li></ul><h3 id="chrome内核架构变迁"><a href="#chrome内核架构变迁" class="headerlink" title="chrome内核架构变迁"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P1.PNG" alt=""></p><p>早期的chrome的架构实际上有以下缺点：</p><ul><li>Renderer线程任务繁重</li><li>无法实时响应缩放滑动操作</li><li>脏区域与滑动重绘区域有冲突<ul><li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li></ul></li></ul><p>当然，经过一系列的发展，Chrome现在是这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P2.PNG" alt=""></p><p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p><p><img src="https://www.10000h.top/images/data_img/webRender/P3.PNG" alt=""></p><p>当然，这种架构也有如下缺点：</p><ul><li>UI线程过于繁忙</li><li>无法支持Canvas的硬件加速以及WebGL</li></ul><p>所以，后期发展成了这样：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P4.PNG" alt=""></p><p>总结看来，内核发展的趋势是：</p><ul><li>多线程化(可以充分利用多核心CPU)</li><li>硬件加速(可以利用GPU)</li></ul><h3 id="分层渲染"><a href="#分层渲染" class="headerlink" title="分层渲染"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p><blockquote><p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p></blockquote><p>网页的分层渲染流程主要是下面这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P7.PNG" alt=""></p><p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p><p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p><ul><li>减少不必要的重新绘制</li><li>可以实现较为复杂的动画</li><li>能够方便实现复杂的CSS样式</li></ul><p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p><ul><li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li><li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li><li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li></ul><p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注:Chrome中符合创建新层的情况：</span><br><span class="line">Layer has 3D or perspective transform CSS properties(有3D元素的属性)</span><br><span class="line">Layer is used by &lt;video&gt; element using accelerated video decoding(video标签并使用加速视频解码)</span><br><span class="line">Layer is used by a &lt;canvas&gt; element with a 3D context or accelerated 2D context(canvas元素并启用3D)</span><br><span class="line">Layer is used for a composited plugin(插件，比如flash)</span><br><span class="line">Layer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)</span><br><span class="line">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class="line">Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)</span><br><span class="line">Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)</span><br></pre></td></tr></table></figure><p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p><ul><li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li><li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li><li>较长较大的页面注意总的分层个数</li><li>避免某一块区域分层过多，面积过大</li></ul><p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p><p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p><p>最后再提出一个小问题：</p><p>以下哪种渲染方式是最优的呢？</p><p><img src="https://www.10000h.top/images/data_img/webRender/P8.PNG" alt=""></p><p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p><h3 id="动画-amp-canvas-amp-WebGl"><a href="#动画-amp-canvas-amp-WebGl" class="headerlink" title="动画 &amp; canvas &amp; WebGl"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p><p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P9.PNG" alt=""></p><p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p><p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p><ul><li>cursor</li><li>font-variant</li><li>opacity</li><li>orphans</li><li>perspective</li><li>perspecti-origin</li><li>pointer-events</li><li>transform</li><li>transform-style</li><li>widows</li></ul><p>想要了解更多内容，可以参考<a href="https://csstriggers.com/" target="_blank" rel="noopener">这里</a></p><p>这方面最终的建议参考如下：</p><ul><li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li><li>动画一定要避免触发大量元素重新排版或者大面积重绘</li><li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li></ul><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P11.PNG" alt=""></p><h3 id="3D-canvas"><a href="#3D-canvas" class="headerlink" title="3D canvas"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p><p>这个时候该怎么办呢？</p><p>2D canvas上场。 </p><p>和CSS动画相比，2D canvas的优点是这样的：</p><ul><li>硬件加速渲染</li><li>渲染流程更优</li></ul><p>其渲染流程如下：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P10.PNG" alt=""></p><p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p><p>HTML 2D canvas 主要绘制如下三种元素：</p><ul><li>图片</li><li>文字</li><li>矢量</li></ul><p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P12.PNG" alt=""></p><p>硬件加速文字绘制的主要流程：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P13.PNG" alt=""></p><p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p><p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p><p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p><h3 id="3D-canvas-WebGL"><a href="#3D-canvas-WebGL" class="headerlink" title="3D canvas(WebGL)"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p><ul><li>通用引擎：threeJS、Pixi</li><li>VR视频的专业引擎：krpano、UtoVR</li><li>H5游戏引擎：Egret、Layabox、Cocos</li></ul><p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p><p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p><hr><p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p><p>其他优质好文：</p><p><a href="http://qingbob.com/javascript-high-performance-animation-and-page-rendering/" target="_blank" rel="noopener">Javascript高性能动画与页面渲染</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS的静态作用域、子程序引用环境与参数传递类型</title>
      <link href="/2017/01/11/JS%E7%9A%84%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%BC%95%E7%94%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/01/11/JS%E7%9A%84%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%BC%95%E7%94%A8%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h4><p>我们先来看下面这个小程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> //JS版本：</span><br><span class="line"> function sub1() &#123;</span><br><span class="line">        var x;</span><br><span class="line">        function sub2() &#123; alert(x); &#125;</span><br><span class="line">        function sub3() &#123; var x; x=3; sub4(sub2); &#125;</span><br><span class="line">        function sub4(subx) &#123; var x; x=4; subx(); &#125;</span><br><span class="line">        x = 1;</span><br><span class="line">        sub3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sub1();</span><br><span class="line">    </span><br><span class="line"> #Python版本</span><br><span class="line">def sub1():</span><br><span class="line">    def sub2():</span><br><span class="line">        print x</span><br><span class="line">    def sub3():</span><br><span class="line">        x=3</span><br><span class="line">        sub4(sub2)</span><br><span class="line">    def sub4(subx):</span><br><span class="line">        x=4</span><br><span class="line">        subx()</span><br><span class="line">    x = 1</span><br><span class="line">    sub3()</span><br><span class="line"></span><br><span class="line">sub1()</span><br></pre></td></tr></table></figure><p>不用亲自运行，实际上输出结果都是1，这可能不难猜到，但是需要解释一番，鉴于Python和JS在这一点上表现的类似，我就以JS来分析。</p><p>我们知道，JS是静态作用域的，所谓静态作用域就是作用域在编译时确定，所以sub2中引用的x，实际上和x=3以及x=4的x没有任何关系，指向第二行的var x;</p><h4 id="子程序的引用环境"><a href="#子程序的引用环境" class="headerlink" title="子程序的引用环境"></a>子程序的引用环境</h4><p>实际上这里面还有一个子程序(注：子程序和函数不是很一样，但我们可以认为子程序包括函数，也约等于函数)的概念，sub2、sub3、sub4都是子程序，对于允许嵌套子程序的语言，应该如何使用执行传递的子程序的引用环境？</p><ul><li>浅绑定：如果这样的话，应该输出4，这对动态作用域的语言来说比较自然。</li><li>深绑定：也就是输出1的情况，这对静态作用域的语言来说比较自然。</li><li>Ad hoc binding: 这是第三种，将子程序作为实际参数传递到调用语句的环境。</li></ul><h4 id="参数传递类型"><a href="#参数传递类型" class="headerlink" title="参数传递类型"></a>参数传递类型</h4><p>参数传递类型我们普遍认为有按值传递和按引用传递两种，实际上不止。</p><p>下面是一张图：</p><p><img src="https://www.10000h.top/images/call.png" alt=""></p><p>这张图对应的第一种传递方式，叫做Pass-by-Value(In mode)，第二种是Pass-by-Result(Out mode)，第三种是Pass-by-Value-Result(Inout mode),图上说的比较明白，实际上如果有result就是说明最后把结果再赋值给参数。</p><p>第二种和第三种编程语言用的少，原因如下：</p><blockquote><p>Potential problem: sub(p1, p1)<br>With the two corresponding formal parameters having different names, whichever formal parameter is copied back last will represent current value of p1</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7下安装和配置redis</title>
      <link href="/2016/10/04/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEredis/"/>
      <url>/2016/10/04/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEredis/</url>
      
        <content type="html"><![CDATA[<p>Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。</p><p> 1 . 下载Redis<br>目前，最新的Redist版本为3.0，使用wget下载，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># wget http://download.redis.io/releases/redis-3.0.4.tar.gz</span><br></pre></td></tr></table></figure></p><p> 2 . 解压Redis<br>下载完成后，使用tar命令解压下载文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># tar -xzvf redis-3.0.4.tar.gz</span><br></pre></td></tr></table></figure></p><p>3 . 编译安装Redis<br>切换至程序目录，并执行make命令编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd redis-3.0.4</span><br><span class="line"># make</span><br></pre></td></tr></table></figure></p><p>执行安装命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># make install</span><br></pre></td></tr></table></figure></p><p>make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：</p><ul><li>redis-server：Redis服务器端启动程序</li><li>redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作</li><li>redis-benchmark：Redis性能测试工具</li><li>redis-check-aof：数据修复工具</li><li>redis-check-dump：检查导出工具</li></ul><p>备注</p><p>有的机器会出现类似以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make[1]: Entering directory `/root/redis/src&apos;</span><br><span class="line">You need tcl 8.5 or newer in order to run the Redis test</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><p>这是因为没有安装tcl导致，yum安装即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install tcl</span><br></pre></td></tr></table></figure></p><p>4 . 配置Redis<br>复制配置文件到/etc/目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp redis.conf /etc/</span><br></pre></td></tr></table></figure></p><p>为了让Redis后台运行，一般还需要修改redis.conf文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/redis.conf</span><br></pre></td></tr></table></figure></p><p>修改daemonize配置项为yes，使Redis进程在后台运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></p><p>5 . 启动Redis<br>配置完成后，启动Redis：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/bin</span><br><span class="line"># ./redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></p><p>检查启动情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef | grep redis</span><br></pre></td></tr></table></figure></p><p>看到类似下面的一行，表示启动成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root     18443     1  0 13:05 ?        00:00:00 ./redis-server *:6379</span><br></pre></td></tr></table></figure></p><p>6 . 添加开机启动项<br>让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。</p><p>为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/usr/local/bin/redis-server /etc/redis.conf&quot; &gt;&gt;/etc/rc.local</span><br></pre></td></tr></table></figure></p><p>7 . Redis配置参数<br>在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize：是否以后台daemon方式运行</span><br><span class="line">pidfile：pid文件位置</span><br><span class="line">port：监听的端口号</span><br><span class="line">timeout：请求超时时间</span><br><span class="line">loglevel：log信息级别</span><br><span class="line">logfile：log文件位置</span><br><span class="line">databases：开启数据库的数量</span><br><span class="line">save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</span><br><span class="line">rdbcompression：是否使用压缩</span><br><span class="line">dbfilename：数据快照文件名（只是文件名）</span><br><span class="line">dir：数据快照的保存目录（仅目录）</span><br><span class="line">appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。</span><br><span class="line">appendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> centOS </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯云北美服务器搭建ShadowSocks代理</title>
      <link href="/2016/08/08/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%8C%97%E7%BE%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAShadowSocks%E4%BB%A3%E7%90%86/"/>
      <url>/2016/08/08/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%8C%97%E7%BE%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAShadowSocks%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>注：本教程适合centos系列和red hat系列</p><p>登陆SSH<br>新的VPS可以先升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><p>有些VPS 没有wget<br>这种要先装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><p>输入以下命令：（可以复制）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>第一行是下载命令，下载东西，第二行是修改权限，第三行是安装命令</p><p>下面是按照配置图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置：</span><br><span class="line">密码：（默认是teddysun.com）</span><br><span class="line">端口：默认是8989</span><br><span class="line">然后按任意键安装，退出按 Ctrl+c</span><br></pre></td></tr></table></figure><p>安装完成会有一个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, shadowsocks install completed!Your Server IP:  ***** VPS的IP地址Your Server Port:  *****  你刚才设置的端口Your Password:  ****  你刚才设置的密码Your Local IP:  127.0.0.1 Your Local Port:  1080 Your Encryption Method:  aes-256-cfb Welcome to visit:https://teddysun.com/342.htmlEnjoy it!</span><br></pre></td></tr></table></figure><p>然后即可以使用</p><p>卸载方法：</p><p>使用 root 用户登录，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocksR.sh uninstall</span><br></pre></td></tr></table></figure><p>安装完成后即已后台启动 ShadowsocksR ，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ShadowSocks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centOS7.2搭建nginx环境以及负载均衡</title>
      <link href="/2016/08/03/centOS7-2%E6%90%AD%E5%BB%BAnginx%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2016/08/03/centOS7-2%E6%90%AD%E5%BB%BAnginx%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="http://i.imgur.com/CaBRleb.jpg" alt="电饭锅"><br> 之所以要整理出这篇文章，是因为1是搭建环境的过程中会遇到大大小小各种问题，2是网上目前也没有关于centos7.2搭建nginx环境的问题整理，因此在这里记录。</p><p>前置工作就不赘述了，首先<code>ssh root@115.29.102.81</code> (换成你们自己的公网IP)登陆进入到自己的服务器命令行，之后开始基本的安装：</p><p><strong>1.添加资源</strong></p><p>添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令(没有换行):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>2.安装Nginx</strong></p><p>在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：</p><blockquote><p><em>这里有一个需要注意的地方，尽量不要用网上的下载源码包然后再传到服务器上的方式进行安装，因为nginx已经不算是简单的Linux了，做了很多扩展，这个时候如果你用源码包安装会出现各种各样的问题，尽量用已经封装好的rpm\yum进行安装</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></p></blockquote><p>Nginx将完成安装在你的CentOS 7 服务器中。</p><p><strong>3.启动Nginx</strong></p><p>刚安装的Nginx不会自行启动。运行Nginx:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure></p><p>如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面</p><blockquote><p>当然，这里一般很可能会无法访问的。</p></blockquote><p>我们先不急于解决我们的问题，先看看nginx的基本配置：</p><p>Nginx配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">网站文件存放默认目录</span><br><span class="line"></span><br><span class="line">/usr/share/nginx/html</span><br><span class="line">网站默认站点配置</span><br><span class="line"></span><br><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。</span><br><span class="line"></span><br><span class="line">/etc/nginx/conf.d/</span><br><span class="line">Nginx全局配置</span><br><span class="line"></span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。</span><br></pre></td></tr></table></figure></p><p>Linux查看公网IP</p><p>您可以运行以下命令来显示你的服务器的公共IP地址:(这个其实没用，不是公网IP)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0 | grep inet | awk &apos;&#123; print $2; &#125;&apos; | sed &apos;s/\/.*$//&apos;</span><br></pre></td></tr></table></figure></p><hr><p>好了，这个时候我们再来看看可能遇到的问题：无法在公网访问。</p><p>这个时候首先看看配置文件default.conf对不对，一个正确的例子：<br>(域名要先进行解析到响应的IP)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  nginx.310058.cn;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">    # concurs with nginx&apos;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>确定文件没问题了，看看这个时候是不是开启了nginx进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>应该会输出一个或者多个进程，如果没有的话就开启或者重启试试看。</p><p>这个时候接下来再试试在服务器上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping  115.29.102.81</span><br><span class="line">telnet 115.29.102.81 80</span><br><span class="line">wget nginx.310058.cn</span><br></pre></td></tr></table></figure></p><p>如果有的命令没有就直接yum安装下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install telnet</span><br></pre></td></tr></table></figure></p><p>如果都可以的话，之后在本机尝试以上三行。如果没有命令也要安装下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure></p><p>发现很可能本机telnet不通，而服务器telnet通。<br>这个时候就是<strong>防火墙</strong>的问题。</p><p>####centos7.2防火墙</p><p>由于centos 7版本以后默认使用firewalld后，网上关于iptables的设置方法已经不管用了，所以根本就别想用配置iptables做啥，根本没用。</p><p>查看下防火墙状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28dcsp7egZ conf.d]# systemctl status firewalld  </span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2016-08-03 12:06:44 CST; 2h 49min ago</span><br><span class="line"> Main PID: 424 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─424 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">Aug 03 12:06:41 iZ28dcsp7egZ systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">Aug 03 12:06:44 iZ28dcsp7egZ systemd[1]: Started firewalld - dynamic firewall daemon.</span><br></pre></td></tr></table></figure></p><p>增加80端口的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></p><p> 别忘了更新防火墙的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>这个时候再<code>restart  nginx.service</code> 一下就会发现应该好了。</p><p>nginx 停止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br><span class="line">也可以重启nginx</span><br><span class="line"></span><br><span class="line">kill -QUIT 进程号  </span><br><span class="line">#从容停止</span><br><span class="line"></span><br><span class="line">kill -TERM 进程号</span><br><span class="line">#或者</span><br><span class="line">kill -INT 进程号</span><br><span class="line">#快速停止</span><br><span class="line"></span><br><span class="line">p-kill -9 nginx</span><br><span class="line">强制停止</span><br><span class="line"></span><br><span class="line">nginx -t </span><br><span class="line">#验证配置文件 前提是进入相应的配置的目录（自己实际测试的时候发现没有进入相应的配置目录也是可以的）</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line">#重启</span><br><span class="line"></span><br><span class="line">kill -HUP 进程号</span><br><span class="line">#重启的另外一种方式</span><br></pre></td></tr></table></figure><p>官方文档地址：<br><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Introduction_to_firewalld</a></p><p>附1:一个简单的负载均衡的实现:<br>weight默认是1，自己也可以更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream mypro &#123;</span><br><span class="line">ip_hash;</span><br><span class="line">                server 111.13.100.92 weight=2;</span><br><span class="line">                server 183.232.41.1;</span><br><span class="line">                server 42.156.140.7;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        server &#123;</span><br><span class="line">                listen 8090;</span><br><span class="line">                location / &#123;</span><br><span class="line">                proxy_pass http://mypro;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>附2:防火墙基本学习：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、firewalld简介</span><br><span class="line">firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念</span><br><span class="line"> </span><br><span class="line">firewalld有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍</span><br><span class="line"> </span><br><span class="line">firewalld的字符界面管理工具是 firewall-cmd </span><br><span class="line"> </span><br><span class="line">firewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，尽量不要修改）和 /etc/firewalld/ （用户配置地址）</span><br><span class="line"> </span><br><span class="line">zone概念：</span><br><span class="line">硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：</span><br><span class="line">drop：默认丢弃所有包</span><br><span class="line">block：拒绝所有外部连接，允许内部发起的连接</span><br><span class="line">public：指定外部连接可以进入</span><br><span class="line">external：这个不太明白，功能上和上面相同，允许指定的外部连接</span><br><span class="line">dmz：和硬件防火墙一样，受限制的公共连接可以进入</span><br><span class="line">work：工作区，概念和workgoup一样，也是指定的外部连接允许</span><br><span class="line">home：类似家庭组</span><br><span class="line">internal：信任所有连接</span><br><span class="line">对防火墙不算太熟悉，还没想明白public、external、dmz、work、home从功能上都需要自定义允许连接，具体使用上的区别还需高人指点</span><br><span class="line"> </span><br><span class="line">2、安装firewalld</span><br><span class="line">root执行 # yum install firewalld firewall-config</span><br><span class="line"> </span><br><span class="line">3、运行、停止、禁用firewalld</span><br><span class="line">启动：# systemctl start  firewalld</span><br><span class="line">查看状态：# systemctl status firewalld 或者 firewall-cmd --state</span><br><span class="line">停止：# systemctl disable firewalld</span><br><span class="line">禁用：# systemctl stop firewalld</span><br><span class="line"> </span><br><span class="line">4、配置firewalld</span><br><span class="line">查看版本：$ firewall-cmd --version</span><br><span class="line">查看帮助：$ firewall-cmd --help</span><br><span class="line">查看设置：</span><br><span class="line">                显示状态：$ firewall-cmd --state</span><br><span class="line">                查看区域信息: $ firewall-cmd --get-active-zones</span><br><span class="line">                查看指定接口所属区域：$ firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">拒绝所有包：# firewall-cmd --panic-on</span><br><span class="line">取消拒绝状态：# firewall-cmd --panic-off</span><br><span class="line">查看是否拒绝：$ firewall-cmd --query-panic</span><br><span class="line"> </span><br><span class="line">更新防火墙规则：# firewall-cmd --reload</span><br><span class="line">                            # firewall-cmd --complete-reload</span><br><span class="line">    两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</span><br><span class="line"> </span><br><span class="line">将接口添加到区域，默认接口都在public</span><br><span class="line"># firewall-cmd --zone=public --add-interface=eth0</span><br><span class="line">永久生效再加上 --permanent 然后reload防火墙</span><br><span class="line"> </span><br><span class="line">设置默认接口区域</span><br><span class="line"># firewall-cmd --set-default-zone=public</span><br><span class="line">立即生效无需重启</span><br><span class="line"> </span><br><span class="line">打开端口（貌似这个才最常用）</span><br><span class="line">查看所有打开的端口：</span><br><span class="line"># firewall-cmd --zone=dmz --list-ports</span><br><span class="line">加入一个端口到区域：</span><br><span class="line"># firewall-cmd --zone=dmz --add-port=8080/tcp</span><br><span class="line">若要永久生效方法同上</span><br><span class="line"> </span><br><span class="line">打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档</span><br><span class="line"># firewall-cmd --zone=work --add-service=smtp</span><br><span class="line"> </span><br><span class="line">移除服务</span><br><span class="line"># firewall-cmd --zone=work --remove-service=smtp</span><br><span class="line"> </span><br><span class="line">还有端口转发功能、自定义复杂规则功能、lockdown，由于还没用到，以后再学习</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centOS </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
